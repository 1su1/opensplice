<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
  <title>OpenSplice DDS Release Notes - Changes and Fixed Bugs V3.4.4</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <link rel="stylesheet" href="../css/prismstyle.css" type="text/css">
  </head>
  <body>
    <p class="back">
      <a href="releasenotes.html">
        Back to Release Notes Page<img src="../images/back.gif" align="middle" 
        height="25" width="30" alt="Back">
      </a>
    </p>

    <h1>Fixed Bugs and Changes V3.4.4</h1>
    <h2>Contents</h2>
    <ul>
      <li><a href="#issues_not_api">Fixed Bugs and Changes not affecting API</a></li>
      <li><a href="#issues_api">Fixed Bugs and Changes affecting API</a></li>
    </ul>
    <hr>
    This page contains a list of all bugfixes and changes incorporated in 
    OpenSplice V3.4.4<br/>
    <h2><a name="issues_not_api">Fixed Bugs and Changes not affecting API</a></h2>
      <p>
        <table width="90%">
        <tr>
          <th width="14%">
            Report ID.
          </th>
          <th width="86%">
            Description
          </th>
        </tr>
        <tr>
          <td>
            4957<br/>
            dds571
          </td>
          <td>
            <b>NumberOfSamplesPurged statistics are incorrect</b><br/>
            <i>
              The OpenSplice DDS reader statistics counters numberOfSamplesPurgedByDispose
              and numberOfSamplesPurgedByNowriters are incorrect.<br/>
              <b>Solution:</b> The statistics were decremented instead of incremented. Problem
              has been fixed.
            </i>
          </td>
        </tr>
        <tr>
          <td>
            5325<br/>
            dds711
          </td>
          <td>
            <b>C++ does not support DDS-Types</b><br/>
            <i>
              <pre><code>
#ifndef OSPL_IDL_COMPILER
#include &lt;dds_dcps.idl&gt;
#endif

module testModule {
  struct dcps_type_usage {
    DDS::Time_t now;
  };
#pragma keylist dcps_type_usage
};
              </code></pre>
              Generating C++ code from the above IDL definition fails.<br/>
              <b>Solution:</b> The OpenSplice IDL preprocessor has been improved to support
              DDS types.
            </i>
          </td>
        </tr>
        <tr>
          <td>
            5959<br/>
            dds991
          </td>
          <td>
            <b>Durability does not fsync persistency files before closing</b><br/>
            <i>
              Durability does not fsync persistency files before closing. To decrease
              fault chances due to power failures, durability should do an "fsync" on
              persistency files before closing them.<br/>
              <b>Solution:</b> Functionality implemented.
            </i>
          </td>
        </tr>
        <tr>
          <td>
            5625<br/>
            dds1018
          </td>
          <td>
            <b>
              OpenSplice DDS Tuner valid data in sample info of database snapshot not correct
            </b><br/>
            <i>
              The valid_data field in the sample info of samples from a datareader database
              snapshot in the OpenSplice DDS Tuner is not correctly set. Sometimes the valid_data
              field is set to FALSE in the snapshot. Another datareader reading the same
              sample shows that the valid_data field is TRUE.<br/>
              <b>Solution:</b> The valid_data field in the sample info is now set to the correct
              value as in the database.
            </i>
          </td>
        </tr>
        <tr>
          <td>
            6094<br/>
            dds1055
          </td>
          <td>
            <b>
              IDL 2 Java, only one union discr. can be used when more should be possible
            </b><br/>
            <i>
              There is a problem with the IDL-to-Java code generation. Consider the following
              example. A union has some ‘case’ statements and a ‘default’. Example: 
              <pre><code>
module demo { 

    enum letter { AA, BB, CC, DD }; 

    union letterbox switch (letter) { 
    case AA : long aa; 
    case BB : long bb; 
    default : long dummy; 
    }; 

}; 
              </code></pre>
              The type associated with the ‘default’ branch is called dummy. For setting the
              dummy value there are two generated setters available:
              <ul> 
                <li>void dummy(value)</li> 
                <li>void dummy(discriminator, value)</li> 
              </ul>
              The first setter sets the discriminator to the first discriminator that maps to
              the dummy element (in the example, discriminator CC), while the second setter
              uses the given discriminator. Now the problem: the getter function. Before
              returning the dummy value, the function checks if the correct discriminator is
              set. Instead of checking for all possible discriminators (which can be set using
              the 2nd setter function!) only the first discriminator is allowed. Looking back
              to the example above, setting discriminators CC and DD for dummy is allowed, but
              the getter function only allows discriminator CC, while also DD should be allowed.<br/>
              <b>Solution:</b> The IDL preprocessor has been adapted to generate code for the getter
              function of the default case that will allow all other values of the discriminator for
              which no case is defined. 
            </i>
          </td>
        </tr>
        <tr>
          <td>
            6139<br/>
            dds1069
          </td>
          <td>
            <b>Durability crash due to mutilated persistent data</b><br/>
            <i>
              When starting a single node with the persistent data present, the durability reports an
              error and crashes with a segmentation fault. The persistent data looks corrupt, but this
              should not lead to a crash of the durability service. The following message is found in
              the error report: 
              <pre><code> 
### Report Message ### 
Version : V3.4.1 
Type : ERROR 
Context : DurabilityService 
File : ../../code/d_storeXML.c 
Line : 3256 
Code : 0 
Description : Data for group '/worlds/SGM_SPL_REAL_WORLD/default_scope/.file_change_cmd' on disk is mutilated. Some data might be lost. 
Node : mfc_1c1 
Process : durability (7096) 
Thread : main thread b7ddc6c0 
Timestamp : 1226925302.051934857 (Mon Nov 17 13:35:02 2008) 
              </code></pre>
              <b>Solution:</b> The durability service will no longer crash on mutilated persistent data.
            </i>
          </td>
        </tr>
        <tr>
          <td>
            6148<br/>
            dds1071
          </td>
          <td>
            <b>
              IDL Preprocessor generated C code cannot be compiled with the C++ compiler
            </b><br/>
            <i>
              Assuming the file BaseModele.idl containing: 
              <pre><code>
module BaseModule { 

  struct sub_structure { 
    unsigned long a; 
    sequence b; 
  }; 

}; 
              </code></pre>
              And the file DependantModule.idl containing: 
              <pre><code>
#include "BaseModule.idl" 

module DependantModule { 

  struct topic_structure { 
    unsigned long long id; 
    BaseModule::sub_structure sub; 
  }; 
#pragma keylist topic_structure id 

}; 
              </code></pre>
              Compiling the idlpp generated C code with a C++ compiler causes the compiler to
              abort on error. With the C compiler less strict rules can be applied such that
              only a warning is given. With the C++ compiler that is not possible and not
              desired. The generated <code>DependantModule_topic_structure__free()</code>
              function is wrong because it does not define the external free function 
              <code>BaseModule_sub_structure__free()</code> before calling it.<br/>
              <b>Solution:</b> The IDL preprocessor has been adapted to generate external
              declarations when a dependant IDL structure has to be freed.
            </i>
          </td>
        </tr>
        <tr>
          <td>
            dds1073
          </td>
          <td>
            <b>
              Splicedaemon and durability lack configurable threads
            </b><br/>
            <i>
              The user can not define thread priorities and scheduling class for durability and splicedaemon
              threads.<br/>
              <b>Solution:</b> Threads are now configurable, see OpenSplice DDS Configurator on how to
              configure the threads and the function of each thread. 
            </i>
          </td>
        </tr>
        <tr>
          <td>
            dds1090
          </td>
          <td>
            <b>DBMSConnect: SQL strings are not properly escaped</b><br/>
            <i>
              When a topic is bridged to DBMS and the topic has a string field that contains an
              SQL-special-character, the topic doesn't get published in the DBMS because the string
              does not get properly escaped.<br/>
              <b>Solution:</b> The SQL statements are now properly escaped.
            </i>
          </td>
        </tr>
        <tr>
          <td>
            dds1091
          </td>
          <td>
            <b>DBMSConnect does not handle database schemas correctly</b><br/>
            <i>
              The DBMSConnect service does not take database schemas into account. This can lead to
              data not being forwarded from DBMS to DDS, because tables cannot be detected.<br/>
              <b>Solution:</b> Problem has been fixed.
            </i>
          </td>
        </tr>
        <tr>
          <td>
            dds1100
          </td>
          <td>
            <b>DBMSConnect: Replication use-case not supported</b><br/>
            <i>
              Using the DBMSConnect service as a database replicator isn't supported because
              data-modifications will keep cascading (which causes unwanted system behaviour). The
              service needs to support this use-case by allowing a specific database user to be
              excluded from the data-bridging.<br/>
              <b>Solution:</b> The DBMSConnect service can now be configured to exclude a database
              user. Use the OpenSplice DDS Configurator to add this configuration option.
            </i>
          </td>
        </tr>
        <tr>
          <td>
            dds1237
          </td>
          <td>
            <b>Writing data with Tuner fails for specific complex types</b><br/>
            <i>
              The OpenSplice DDS Tuner fails to write data for types with unbounded sequence
              of structures.<br/>
              <b>Solution:</b> The OpenSplice DDS Tuner is now capable of writing data for types
              with unbounded sequences of structures.
            </i>
          </td>
        </tr>
        </table>
      </p>
      
    <h2><a name="issues_api">Fixed Bugs and Changes affecting API</a></h2>
      <p>
        No changes were made affecting the API.
      </p>
    <br/>
    <hr>
    <p>
      <a target="_top" href="http://www.prismtech.com">
      <img src="../images/logo_prismtech2.jpg" align="right"
           width="112" height="29" border="0" alt="PrismTech"></a> 
      <a href="#top" target="_self">
      <img src="../images/top.gif" width="32" 
           height="32" border="0" alt="TOP"></a><br/>
      <a href="#top" target="_self">Top</a>
    </p>
  </body>
</html>
