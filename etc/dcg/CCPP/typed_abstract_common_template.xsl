<?xml version="1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xalan="http://xml.apache.org/xalan"
    xmlns:redirect="http://xml.apache.org/xalan/redirect"
    extension-element-prefixes="redirect">
    <xsl:include href="common_dlrl.xsl"/>

    <xsl:template name ="typedObject__contructor">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="nonPrefixedName"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>
        <!--The following code is generated by this template for example type 'Foo' defined in module 'test'
            test::Foo_abstract::Foo_abstract() : currentTopic(NULL), previousTopic(NULL)
            {
            }
         Or in header mode:
                protected:
                    Foo_abstract();

        -->
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
                <xsl:text>protected:</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$white-space"/>
                <xsl:text>    </xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$nonPrefixedName"/>
        <xsl:text>_abstract()</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='header'">
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>: currentTopic(NULL), previousTopic(NULL)</xsl:text>
                <xsl:for-each select="STATEMEMBER">
                    <xsl:if test="multiPlaceTopic or keyDescription">
                        <xsl:variable name="prefixedAttributeName">
                            <xsl:call-template name="ccpp-name">
                                <xsl:with-param name="name" select="DECLARATOR/@NAME"/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:text>, </xsl:text>
                        <xsl:value-of select="$prefixedAttributeName"/>
                        <xsl:text>(NULL)</xsl:text>
                    </xsl:if>
                </xsl:for-each>
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL"/>
    </xsl:template>

    <xsl:template name ="typedObject__destructor">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="nonPrefixedName"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <!--The following code is generated by this template for example type 'Foo' defined in module 'test', in this example
            it has one monoRelation myGov and one multiRelation myGovs
            test::Foo_abstract::~Foo_abstract()
            {
                if(previousTopic)
                {
                    delete previousTopic;
                }
                if(currentTopic)
                {
                    delete currentTopic;
                }
            }

         Or in header mode:
                protected:
                    virtual ~Foo_abstract();
        -->
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::~</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
                <xsl:text>protected:</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$white-space"/>
                <xsl:text>    virtual ~</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$nonPrefixedName"/>
        <xsl:text>_abstract()</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    if(previousTopic)</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    {</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        delete previousTopic;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    }</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    if(currentTopic)</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    {</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        delete currentTopic;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    }</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL"/>
    </xsl:template>

    <xsl:template match="STATEMEMBER" mode="accessors">
        <xsl:param name="mainTopicName"/>
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <xsl:choose>
            <!-- is it a mono attribute? -->
            <xsl:when test="valueField">
                <xsl:call-template name="generate-statemember-visibility">
                    <xsl:with-param name="white-space" select="$white-space"/>
                    <xsl:with-param name="mode" select="$mode"/>
                </xsl:call-template>
                <xsl:call-template name="generate-monoAttribute-operations">
                    <xsl:with-param name="mainTopicName" select="$mainTopicName"/>
                    <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
                    <xsl:with-param name="white-space">
                        <xsl:value-of select="$white-space"/>
                        <xsl:text>    </xsl:text>
                    </xsl:with-param>
                    <xsl:with-param name="mode" select="$mode"/>
                </xsl:call-template>
            </xsl:when>
            <!-- or is it a monoRelation? -->
            <xsl:when test="keyDescription and not (multiPlaceTopic)">
                <xsl:call-template name="generate-statemember-visibility">
                    <xsl:with-param name="white-space" select="$white-space"/>
                    <xsl:with-param name="mode" select="$mode"/>
                </xsl:call-template>
                <xsl:call-template name="generate-monoRelation-operations">
                    <xsl:with-param name="mainTopicName" select="$mainTopicName"/>
                    <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
                    <xsl:with-param name="white-space">
                        <xsl:value-of select="$white-space"/>
                        <xsl:text>    </xsl:text>
                    </xsl:with-param>
                    <xsl:with-param name="mode" select="$mode"/>
                </xsl:call-template>
            </xsl:when>
            <!-- or is it a multiRelation? -->
            <xsl:when test="multiPlaceTopic">
                <xsl:call-template name="generate-statemember-visibility">
                    <xsl:with-param name="white-space" select="$white-space"/>
                    <xsl:with-param name="mode" select="$mode"/>
                </xsl:call-template>
                <xsl:call-template name="generate-multiRelation-operations">
                    <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
                    <xsl:with-param name="white-space">
                        <xsl:value-of select="$white-space"/>
                        <xsl:text>    </xsl:text>
                    </xsl:with-param>
                    <xsl:with-param name="mode" select="$mode"/>
                </xsl:call-template>
            </xsl:when>
            <!-- if none of the above it must be a local attribute (multi attribute is not supported)
                And for local atrributes we dont have to do anything in this file.
            -->
        </xsl:choose>
    </xsl:template>

    <xsl:template name="generate-statemember-visibility">
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <xsl:if test="$mode='header'">
            <xsl:variable name="visibility">
                <xsl:call-template name="statemember-visibility"/>
            </xsl:variable>

            <xsl:value-of select="$white-space"/>
            <xsl:value-of select="$visibility"/>
            <xsl:text>:</xsl:text>
            <xsl:value-of select="$NL"/>
        </xsl:if>
    </xsl:template>

    <xsl:template name="generate-monoAttribute-operations">
        <xsl:param name="mainTopicName"/>
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <xsl:variable name="attributeName" select="DECLARATOR/@NAME" />
        <xsl:variable name="idlType">
            <xsl:call-template name="resolveStatememberIdlType"/>
        </xsl:variable>
        <xsl:variable name="attributeType">
            <xsl:call-template name="get-ccpp-type-for-resolved-idl-type">
                <xsl:with-param name="idlType" select="$idlType"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="typeHasVarLength" select="@typeHasVarLength"/>
        <xsl:variable name="arrayBrackets">
            <xsl:call-template name="get-array-brackets">
                <xsl:with-param name="action" select="'bracket-only'"/>
                <xsl:with-param name="userData" select="'0'"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="prefixedTopicFieldName">
            <xsl:call-template name="ccpp-name">
                <xsl:with-param name="name" select="valueField"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="must-setter-be-generated">
            <xsl:call-template name="must-monoAttribute-setter-be-generated">
                <xsl:with-param name="valueFieldName" select="valueField"/>
                <xsl:with-param name="topicName" select="$mainTopicName"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="idlTypeSpec">
            <xsl:call-template name="get-idl-type-spec-id"/>
        </xsl:variable>

        <xsl:call-template name="monoAttribute__get">
            <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
            <xsl:with-param name="attributeName" select="$attributeName"/>
            <xsl:with-param name="attributeType" select="$attributeType"/>
            <xsl:with-param name="typeHasVarLength" select="$typeHasVarLength"/>
            <xsl:with-param name="arrayBrackets" select="$arrayBrackets"/>
            <xsl:with-param name="prefixedTopicFieldName" select="$prefixedTopicFieldName"/>
            <xsl:with-param name="idlTypeSpec" select="$idlTypeSpec"/>
            <xsl:with-param name="white-space" select="$white-space"/>
            <xsl:with-param name="mode" select="$mode"/>
            <xsl:with-param name="attributeCppType">
                <xsl:call-template name="get-cpp-type-for-statemember-or-operation">
                    <xsl:with-param name="type" select="TYPEREF/@TYPE"/>
                    <xsl:with-param name="attributeName" select="$attributeName"/>
                    <xsl:with-param name="varLength" select="$typeHasVarLength"/><!-- true or false -->
                    <xsl:with-param name="idlParamArg" select="'return'"/><!-- in, out, inout or return -->
                </xsl:call-template>
            </xsl:with-param>
            <xsl:with-param name="attributeCppNormalType">
                <xsl:call-template name="get-cpp-type-for-statemember-or-operation">
                    <xsl:with-param name="type" select="TYPEREF/@TYPE"/>
                    <xsl:with-param name="attributeName" select="$attributeName"/>
                    <xsl:with-param name="varLength" select="$typeHasVarLength"/><!-- true or false -->
                    <xsl:with-param name="idlParamArg" select="'none'"/><!-- in, out, inout or return -->
                </xsl:call-template>
            </xsl:with-param>
        </xsl:call-template>

        <xsl:if test="string-length($must-setter-be-generated)=0">
            <xsl:variable name="isImmutable">
                <xsl:call-template name="determineMonoAttributeImmutabilityFromWithinStateMemberElement">
                    <xsl:with-param name="dcpsFieldName" select="valueField"/>
                    <xsl:with-param name="topicName" select="$mainTopicName"/>
                    <xsl:with-param name="trueVal">
                        <xsl:text>TRUE</xsl:text>
                    </xsl:with-param>
                    <xsl:with-param name="falseVal">
                        <xsl:text>FALSE</xsl:text>
                    </xsl:with-param>
                    <xsl:with-param name="white-space" select="$white-space"/>
                    <xsl:with-param name="mode" select="$mode"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:call-template name="monoAttribute__set">
                <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
                <xsl:with-param name="attributeName" select="$attributeName"/>
                <xsl:with-param name="immutable" select="$isImmutable"/>
                <xsl:with-param name="attributeType" select="$attributeType"/>
                <xsl:with-param name="typeHasVarLength" select="$typeHasVarLength"/>
                <xsl:with-param name="arrayBrackets" select="$arrayBrackets"/>
                <xsl:with-param name="prefixedTopicFieldName" select="$prefixedTopicFieldName"/>
                <xsl:with-param name="white-space" select="$white-space"/>
                <xsl:with-param name="mode" select="$mode"/>
                <xsl:with-param name="idlTypeSpec" select="$idlTypeSpec"/>
                <xsl:with-param name="attributeCppType">
                    <xsl:call-template name="get-cpp-type-for-statemember-or-operation">
                        <xsl:with-param name="type" select="TYPEREF/@TYPE"/>
                        <xsl:with-param name="attributeName" select="$attributeName"/>
                        <xsl:with-param name="varLength" select="$typeHasVarLength"/><!-- true or false -->
                        <xsl:with-param name="idlParamArg" select="'in'"/><!-- in, out, inout or return -->
                    </xsl:call-template>
                </xsl:with-param>
                <xsl:with-param name="attributeCppNormalType">
                    <xsl:call-template name="get-cpp-type-for-statemember-or-operation">
                        <xsl:with-param name="type" select="TYPEREF/@TYPE"/>
                        <xsl:with-param name="attributeName" select="$attributeName"/>
                        <xsl:with-param name="varLength" select="$typeHasVarLength"/><!-- true or false -->
                        <xsl:with-param name="idlParamArg" select="'none'"/><!-- in, out, inout or return -->
                    </xsl:call-template>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:if>
        <xsl:call-template name="monoAttribute__is_xxx_modified">
            <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
            <xsl:with-param name="attributeName" select="$attributeName"/>
            <xsl:with-param name="attributeType" select="$attributeType"/>
            <xsl:with-param name="prefixedTopicFieldName" select="$prefixedTopicFieldName"/>
            <xsl:with-param name="idlTypeSpec" select="$idlTypeSpec"/>
            <xsl:with-param name="white-space" select="$white-space"/>
            <xsl:with-param name="mode" select="$mode"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="monoAttribute__get">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="attributeName"/>
        <xsl:param name="attributeType"/>
        <xsl:param name="arrayBrackets"/>
        <xsl:param name="typeHasVarLength"/>
        <xsl:param name="prefixedTopicFieldName"/>
        <xsl:param name="idlTypeSpec"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>
        <xsl:param name="attributeCppType"/>
        <xsl:param name="attributeCppNormalType"/>

        <!-- Generates the following code for shared attribute 'public long myX'
            in valuetype 'Foo' defined in module 'test' mapped onto topic member 'x':

            CORBA::Long
            test::Foo_abstract::get_x(
                )
            {
                DLRL_INFO(INF_ENTER);

                DLRL_INFO(INF_EXIT);
                return currentTopic->x;
            }

            or in header mode:
            /**
             * Returns the 'shared' x attribute. If the object state was not yet available,
             * it will be fetched from the DCPS.
             *
             * @return the corresponding attribute.
             */
            CORBA::Long
            get_x(
                );
        -->
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
            <xsl:text>/**</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * Returns the 'shared' </xsl:text>
            <xsl:value-of select="$attributeName"/>
            <xsl:text> attribute. If the object state was not yet available,</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * it will be fetched from the DCPS.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> *</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @return the corresponding attribute.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> */</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:value-of select="$attributeCppType"/>
        <xsl:value-of select="$NL"/>
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>get_</xsl:text>
        <xsl:value-of select="$attributeName"/>
        <xsl:text>(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>    )</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='header'">
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_ENTER);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_EXIT);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:choose>
                    <xsl:when test="$idlTypeSpec='STRING' or $idlTypeSpec='WSTRING'">
                        <xsl:text>    return </xsl:text>
                        <xsl:call-template name="get_corba_module_name"/>
                        <xsl:text>::string_dup(</xsl:text>
                        <xsl:text>currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>);</xsl:text>
                        <xsl:value-of select="$NL" />
                    </xsl:when>
                    <xsl:when test="$typeHasVarLength='true' and $idlTypeSpec='UNBOUNDED_SEQUENCE'">
                        <xsl:value-of select="$NL"/>
                        <xsl:text>    </xsl:text>
                        <xsl:call-template name="get_corba_module_name"/>
                        <xsl:text>::ULong len, i = 0;</xsl:text>
                        <xsl:value-of select="$NL" />
                        <xsl:text>    </xsl:text>
                        <xsl:value-of select="$attributeCppNormalType"/>
                        <xsl:text> *f = new </xsl:text>
                        <xsl:value-of select="$attributeCppNormalType"/>
                        <xsl:text>();</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>    len = currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>.length();</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>    f->length(len);</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>    for (i = 0; i &lt; len; i++)</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>    {</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>        f[i] = currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>[i];</xsl:text>
                        <xsl:value-of select="$NL" />
                        <xsl:text>    }</xsl:text>
                        <xsl:value-of select="$NL" />
                        <xsl:text>    return f;</xsl:text>
                        <xsl:value-of select="$NL" />
                    </xsl:when>
                    <xsl:when test="$typeHasVarLength='true' and ($idlTypeSpec='ANY' or $idlTypeSpec='STRUCT' or $idlTypeSpec='UNION' or $idlTypeSpec='BOUNDED_SEQUENCE')">
                        <xsl:text>    return new </xsl:text>
                        <xsl:value-of select="$attributeCppNormalType"/>
                        <xsl:text>(currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>);</xsl:text>
                        <xsl:value-of select="$NL" />
                    </xsl:when>
                    <xsl:when test="$idlTypeSpec='ARRAY'">
                        <xsl:text>    return </xsl:text>
                        <xsl:value-of select="$attributeCppNormalType"/>
                        <xsl:text>_dup(currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>);</xsl:text>
                        <xsl:value-of select="$NL" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>    return currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>;</xsl:text>
                        <xsl:value-of select="$NL" />
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL" />
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL" />
    </xsl:template>

    <xsl:template name="monoAttribute__is_xxx_modified">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="attributeName"/>
        <xsl:param name="attributeType"/>
        <xsl:param name="prefixedTopicFieldName"/>
        <xsl:param name="idlTypeSpec"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <!-- Generates the following code for shared attribute 'public long myX'
            in valuetype 'Foo' defined in module 'test' mapped onto topic member 'x':

            CORBA::Boolean
            test::Foo_abstract::is_myX_modified(
                )
            {
                DLRL_INFO(INF_ENTER);

                DLRL_INFO(INF_EXIT);
                return prevTopicValid && (currentTopic->x != previousTopic->x);
            }
            or in header mode:
            /**
             * Returns <code>true</code> if the 'shared' myX attribute has
             * been modified in the previous update round, <code>false</code> if not. For objects with
             * read_state NEW or VOID <code>false</code> is always returned. If the object state was not yet available,
             * it will be fetched from the DCPS.
             * Currently union, sequences and struct attributes will always indicate they are modified.
             *
             * @return the corresponding attribute.
             */
            CORBA::Boolean
            is_myX_modified(
                );
         -->
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
            <xsl:text>/**</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * Returns &lt;code>true&lt;/code> if the 'shared' </xsl:text>
            <xsl:value-of select="$attributeName"/>
            <xsl:text> attribute has</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * been modified in the previous update round, &lt;code>false&lt;/code> if not. For objects with</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * read_state NEW or VOID &lt;code>false&lt;/code> is always returned. If the object state was not yet available,</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * it will be fetched from the DCPS.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * Currently union, sequences and struct attributes will always indicate they are modified.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> *</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @return the corresponding attribute.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> */</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:call-template name="get_corba_module_name"/>
        <xsl:text>::Boolean</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>is_</xsl:text>
        <xsl:value-of select="$attributeName"/>
        <xsl:text>_modified(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>    )</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='header'">
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_ENTER);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_EXIT);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    return prevTopicValid &amp;&amp; (</xsl:text>

                <xsl:choose>
                    <xsl:when test="$idlTypeSpec='STRING' or $idlTypeSpec='WSTRING' ">
                        <xsl:text>0 != strcmp(currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>, previousTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>));</xsl:text>
                        <xsl:value-of select="$NL"/>
                    </xsl:when>
                    <xsl:when test="$idlTypeSpec='ENUM'">
                        <xsl:text>currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text> != previousTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>);</xsl:text>
                        <xsl:value-of select="$NL"/>
                    </xsl:when>
                    <xsl:when test="$idlTypeSpec='STRUCT'">
                        <xsl:text>true);//structs always return true for the moment</xsl:text>
                        <xsl:value-of select="$NL"/>
                    </xsl:when>
                    <xsl:when test="$idlTypeSpec='UNION'">
                        <xsl:text>true);//unions always return true for the moment</xsl:text>
                        <xsl:value-of select="$NL"/>
                    </xsl:when>
                    <xsl:when test="$idlTypeSpec='SIMPLE' or $idlTypeSpec='ANY'">
                        <xsl:text>currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text> != previousTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>);</xsl:text>
                        <xsl:value-of select="$NL"/>
                    </xsl:when>
                    <xsl:otherwise><!-- must be sequence or unknown, either case return true. -->
                        <xsl:text>true);</xsl:text>
                        <xsl:value-of select="$NL"/>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL"/>
    </xsl:template>

    <xsl:template name="monoAttribute__set">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="attributeName"/>
        <xsl:param name="immutable"/>
        <xsl:param name="attributeType"/>
        <xsl:param name="arrayBrackets"/>
        <xsl:param name="prefixedTopicFieldName"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>
        <xsl:param name="idlTypeSpec"/>
        <xsl:param name="attributeCppType"/>
        <xsl:param name="attributeCppNormalType"/>

        <!-- Generates the following code for shared attribute 'public long myX'
            in valuetype 'Foo' defined in module 'test' mapped onto topic member 'x':

            void
            test::Foo_abstract::set_myX(
                CORBA::Long value) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet)
            {
                DLRL_Exception exception;

                DLRL_INFO(INF_ENTER);

                DLRL_Exception_init(&exception);

                /*first validate if the change is allowed, if not an exception will be raised.*/
                DK_ObjectAdmin_ts_stateHasChanged(
                    object,
                    &exception,
                    NULL,
                    TRUE);
                DLRL_Exception_PROPAGATE(&exception);
                currentTopic->x = value;

                DLRL_Exception_EXIT(&exception);
                DLRL_INFO(INF_EXIT);
                ccpp_DlrlUtils_us_handleException(&exception);
            }

            or in header mode:
            /**
             * Sets the 'shared' myX attribute.
             *
             * A PreconditionNotMet is raised if any of the following preconditions is violated:
             * - ObjectRoot is not in a (writeable) cacheaccess;
             * - ObjectRoot is already registered (i.e. identity may not be changed anymore),
             * as this field represents a 'key' field of this object.
             * @param value the new value for the corresponding attribute.
             * @throws DDS.AlreadyDeleted if the object being manipulated is already deleted
             * @throws DDS.PreconditionNotMet if any of the preconditions are not met.
             */
            void
            set_myX(
                CORBA::Long value) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet);
        -->
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
            <xsl:text>/**</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * Sets the 'shared' </xsl:text>
            <xsl:value-of select="$attributeName"/>
            <xsl:text> attribute.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> *</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * A PreconditionNotMet is raised if any of the following preconditions is violated:</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * - ObjectRoot is not in a (writeable) cacheaccess;</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * - ObjectRoot is already registered (i.e. identity may not be changed anymore), </xsl:text>
            <xsl:text> * as this field represents a 'key' field of this object.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @param value the new value for the corresponding attribute.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @throws DDS.AlreadyDeleted if the object being manipulated is already deleted</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @throws DDS.PreconditionNotMet if any of the preconditions are not met.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> */</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>void</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>set_</xsl:text>
        <xsl:value-of select="$attributeName"/>
        <xsl:text>(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>    </xsl:text>
        <xsl:value-of select="$attributeCppType"/>
        <xsl:text> value) THROW_ORB_AND_USER_EXCEPTIONS(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>        DDS::PreconditionNotMet)</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='header'">
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception exception;</xsl:text>
                <xsl:choose>
                    <xsl:when test="$idlTypeSpec='UNBOUNDED_SEQUENCE'">
                      <xsl:value-of select="$NL"/>
                      <xsl:text>    </xsl:text>
                      <xsl:call-template name="get_corba_module_name"/>
                      <xsl:text>::ULong len, i = 0;</xsl:text>
                    </xsl:when>
                 </xsl:choose>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_ENTER);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_init(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    /*first validate if the change is allowed, if not an exception will be raised.*/</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DK_ObjectAdmin_ts_stateHasChanged(</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        object,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        &amp;exception,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        NULL,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        </xsl:text>
                <xsl:value-of select="$immutable"/>
                <xsl:text>);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_PROPAGATE(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>

                <xsl:choose>
                    <xsl:when test="$idlTypeSpec='STRING' or $idlTypeSpec='WSTRING'">
                        <xsl:text>    currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text> = </xsl:text>
                        <xsl:call-template name="get_corba_module_name"/>
                        <xsl:text>::string_dup(value);</xsl:text>
                        <xsl:value-of select="$NL" />
                    </xsl:when>
                    <xsl:when test="$idlTypeSpec='ARRAY'">
                        <xsl:text>    </xsl:text>
                        <xsl:value-of select="$attributeCppNormalType"/>
                        <xsl:text>_copy(currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text>, value);</xsl:text>
                        <xsl:value-of select="$NL" />
                    </xsl:when>
                    <xsl:when test="$idlTypeSpec='UNBOUNDED_SEQUENCE'">
                      <xsl:text>    currentTopic-></xsl:text>
                      <xsl:value-of select="$prefixedTopicFieldName"/>
                      <xsl:text>.length(len);</xsl:text>
                      <xsl:value-of select="$NL"/>
                      <xsl:text>    for (i = 0; i &lt; len; i++)</xsl:text>
                      <xsl:value-of select="$NL"/>
                      <xsl:text>    {</xsl:text>
                      <xsl:value-of select="$NL"/>
                      <xsl:text>        currentTopic-></xsl:text>
                      <xsl:value-of select="$prefixedTopicFieldName"/>
                      <xsl:text>[i] = value[i];</xsl:text>
                      <xsl:value-of select="$NL" />
                      <xsl:text>    }</xsl:text>
                      <xsl:value-of select="$NL" />
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>    currentTopic-></xsl:text>
                        <xsl:value-of select="$prefixedTopicFieldName"/>
                        <xsl:text> = value;</xsl:text>
                        <xsl:value-of select="$NL"/>
                    </xsl:otherwise>
                </xsl:choose>

                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_EXIT(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_EXIT);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    ccpp_DlrlUtils_us_handleException(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL"/>
    </xsl:template>

    <xsl:template name="generate-monoRelation-operations">
        <xsl:param name="mainTopicName"/>
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <xsl:variable name="attributeName" select="DECLARATOR/@NAME" />
        <xsl:variable name="returnType">
            <xsl:variable name="idlType">
                <xsl:call-template name="resolveStatememberIdlType"/>
            </xsl:variable>
            <xsl:call-template name="string-search-replace">
                <xsl:with-param name="text" select="$idlType"/>
                <xsl:with-param name="from" select="'::'"/>
                <xsl:with-param name="to" select="'::'"/>
                <xsl:with-param name="prefixKeywords" select="'yes'"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="index" select="TYPEREF/@INDEX"/>
        <xsl:variable name="relationHasForeignKeys">
            <xsl:call-template name="hasForeignKeysForMonoRelation">
                <xsl:with-param name="topicName" select="$mainTopicName"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:call-template name="monoRelation__get">
            <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
            <xsl:with-param name="attributeName" select="$attributeName"/>
            <xsl:with-param name="returnType" select="$returnType"/>
            <xsl:with-param name="relationIndex" select="$index"/>
            <xsl:with-param name="white-space" select="$white-space"/>
            <xsl:with-param name="mode" select="$mode"/>
        </xsl:call-template>
        <xsl:call-template name="monoRelation__set">
            <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
            <xsl:with-param name="attributeName" select="$attributeName"/>
            <xsl:with-param name="returnType" select="$returnType"/>
            <xsl:with-param name="index" select="$index"/>
            <xsl:with-param name="relationHasForeignKeys" select="$relationHasForeignKeys"/>
            <xsl:with-param name="topicName" select="$mainTopicName"/>
            <xsl:with-param name="white-space" select="$white-space"/>
            <xsl:with-param name="mode" select="$mode"/>
        </xsl:call-template>
        <xsl:call-template name="monoRelation__is_xxx_modified">
            <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
            <xsl:with-param name="attributeName" select="$attributeName"/>
            <xsl:with-param name="white-space" select="$white-space"/>
            <xsl:with-param name="mode" select="$mode"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="monoRelation__get">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="attributeName"/>
        <xsl:param name="returnType"/>
        <xsl:param name="relationIndex"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <xsl:variable name="prefixedAttributeName">
            <xsl:call-template name="ccpp-name">
                <xsl:with-param name="name" select="DECLARATOR/@NAME"/>
            </xsl:call-template>
        </xsl:variable>
        <!-- is this mono relation optional? A validityField indicates
            it is optional, and any mono relation mapped onto a
            SimpleOid or FullOid type is optional by default
        -->
        <xsl:variable name="isOptional">
            <xsl:choose>
                <xsl:when test="validityField">
                    <xsl:text>TRUE</xsl:text>
                </xsl:when>
                <xsl:when test="keyDescription/@content!='NoOid'">
                    <xsl:text>TRUE</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>FALSE</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <!--The following code is generated by this template for example type 'Foo' defined in module 'test'
            with monoRelation 'myBar' of type 'test::Bar'
            test::Bar*
            test::Foo_abstract::get_myBar(
                ) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::NotFound)
            {
                test::Bar* retVal = NULL;
                DLRL_Exception exception;

                DLRL_INFO(INF_ENTER);

                DLRL_Exception_init(&exception);

                DK_ObjectAdmin_lockHome(object);
                DK_ObjectAdmin_us_checkAlive(object, &exception);
                DLRL_Exception_PROPAGATE(&exception);

                if(myBar)
                {
                    retVal = myBar;
                    myBar->_add_ref();
                }
            /* generate this 'else' branch for optional relations: */
                else
                {
                    DK_ObjectAdmin_us_checkRelationIsFound(object, &exception, 0);
                    DLRL_Exception_PROPAGATE(&exception);
                }
            /* generate this 'else' branch for mandatory relations: */
                else
                {
                    DLRL_Exception_THROW(&exception, DLRL_NOT_FOUND, "The related object represented by attribute 'myBar' could not be located by the DLRL");
                }

                DLRL_Exception_EXIT(&exception);
                DK_ObjectAdmin_unlockHome(object);
                DLRL_INFO(INF_EXIT);
                ccpp_DlrlUtils_us_handleException(&exception);
                return retVal;
            }

            or in mode 'header'
            /**
             * Returns a reference to the related 'myBar' test::Bar. If the related object's state
             * is not yet available in DCPS, a DDS::NotFound exception will be thrown.
             *
             * @return the related object or null if no relation is managed.
             * @throws DDS::NotFound
             *            if the related object cannot be found.
             * @throws DDS::AlreadyDeleted if the current Object is already deleted.
             */
            test::Bar*
            test::Foo_abstract::get_myBar(
                ) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::NotFound);

        -->
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
            <xsl:text>/**</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * Returns a reference to the related '</xsl:text>
            <xsl:value-of select="$attributeName"/>
            <xsl:text>' </xsl:text>
            <xsl:value-of select="$returnType"/>
            <xsl:text>. If the related object's state</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * is not yet available in DCPS, a DDS::NotFound exception will be thrown.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> *</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @return the related object or null if no relation is managed.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @throws DDS::NotFound</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> *            if the related object cannot be found.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @throws DDS::AlreadyDeleted if the current Object is already deleted.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> */</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:value-of select="$returnType"/>
        <xsl:text>*</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>get_</xsl:text>
        <xsl:value-of select="$attributeName"/>
        <xsl:text>(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>    ) THROW_ORB_AND_USER_EXCEPTIONS(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>        DDS::NotFound)</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='header'">
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    </xsl:text>
                <xsl:value-of select="$returnType"/>
                <xsl:text>* retVal = NULL;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception exception;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_ENTER);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_init(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DK_ObjectAdmin_lockHome(object);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DK_ObjectAdmin_us_checkAlive(object, &amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_PROPAGATE(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    if(</xsl:text>
                <xsl:value-of select="$prefixedAttributeName"/>
                <xsl:text>)</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    {</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        retVal = </xsl:text>
                <xsl:value-of select="$prefixedAttributeName"/>
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        </xsl:text>
                <xsl:value-of select="$prefixedAttributeName"/>
                <xsl:text>->_add_ref();</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    }</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:choose>
                    <xsl:when test="$isOptional='TRUE'">
                        <xsl:text>    else</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>    {</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>        DK_ObjectAdmin_us_checkRelationIsFound(object, &amp;exception, </xsl:text>
                        <xsl:value-of select="$relationIndex"/>
                        <xsl:text>);</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>        DLRL_Exception_PROPAGATE(&amp;exception);</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>    }</xsl:text>
                        <xsl:value-of select="$NL"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>    else</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>    {</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>        DLRL_Exception_THROW(&amp;exception, DLRL_NOT_FOUND, "The related object represented by attribute '</xsl:text>
                        <xsl:value-of select="$attributeName"/>
                        <xsl:text>' could not be located by the DLRL");</xsl:text>
                        <xsl:value-of select="$NL"/>
                        <xsl:text>    }</xsl:text>
                        <xsl:value-of select="$NL"/>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_EXIT(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DK_ObjectAdmin_unlockHome(object);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_EXIT);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    ccpp_DlrlUtils_us_handleException(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    return retVal;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL"/>
    </xsl:template>

    <xsl:template name ="monoRelation__is_xxx_modified">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="attributeName"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <!--The following code is generated by this template for example type 'Foo' defined in module 'test'
            with monoRelation 'myBar':

            CORBA::Boolean
            test::Foo_abstract::is_myBar_modified(
                DDS::ObjectScope scope)
            {
                DLRL_INFO(INF_ENTER);

                /* not supported for relations */

                DLRL_INFO(INF_EXIT);
                return FALSE;
            }

        -->
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
            <xsl:text>/**</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * Not supported, always returns FALSE</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> */</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:call-template name="get_corba_module_name"/>
        <xsl:text>::Boolean</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>is_</xsl:text>
        <xsl:value-of select="$attributeName"/>
        <xsl:text>_modified(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>    DDS::ObjectScope scope)</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='header'">
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_ENTER);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    /* not supported for relations */</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_EXIT);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    return false;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL"/>
    </xsl:template>

    <xsl:template name="monoRelation__set">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="attributeName"/>
        <xsl:param name="returnType"/>
        <xsl:param name="index"/>
        <xsl:param name="relationHasForeignKeys"/>
        <xsl:param name="topicName"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>
        <xsl:variable name="prefixedAttributeName">
            <xsl:call-template name="ccpp-name">
                <xsl:with-param name="name" select="$attributeName"/>
            </xsl:call-template>
        </xsl:variable>

        <!--The following code is generated by this template for example type 'Foo' defined in module 'test'
            with monoRelation 'myBar' of type 'test::Bar':

            void
            test::Foo_abstract::set_myBar(
                test::Bar* value) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet)
            {
                DLRL_Exception exception;
                DK_ObjectAdmin* objAdmin = NULL;

                DLRL_INFO(INF_ENTER);

                DLRL_Exception_init(&exception);
                if(value)
                {
                    objAdmin = getObjectRootAdmin(&exception, value, "value");
                }
                DK_ObjectAdmin_ts_changeRelation(
                    object,
                    &exception,
                    NULL,
                    0,
                    objAdmin);
                DLRL_Exception_PROPAGATE(&exception);
                if(myBar)
                {
                    myBar->_remove_ref();
                }
                myBar = value;
                if(myBar)
                {
                    myBar->_add_ref();
                }
                /* Change the values in the topic */
                if(value)
                {
                    currentTopic->myBarIDName = val->get_barIDName();
                    currentTopic->myBarIDNumber = val->get_barIDNumber();
                }

                DLRL_Exception_EXIT(&exception);
                DLRL_INFO(INF_EXIT);
                ccpp_DlrlUtils_us_handleException(&exception);
            }

            or in mode 'header':
            /**
             * Sets a reference to the related 'myBar' object. Relationships may only
             * be set between registered objects. If this or one of the other
             * preconditions is not met, an exception is raised.
             *
             * A PreconditionNotMet is raised if any of the following preconditions is
             * violated:
             * <ul><li>'Owner' ObjectRoot is not in a (writeable) CacheAccess;</li>
             * <li>If the value of the parameter is NIL, but the relation was modeled
             * as a mandatory relation;</li>
             * <li>If the ObjectRoot in the parameter ('target') has different keys
             * then the 'owner' ObjectRoot and the relation is mapped using so called
             * 'shared' keys;</li>
             * <li>'Owner' ObjectRoot is not yet registered;</li>
             * <li>'Target' ObjectRoot is not yet registered;</li>
             * <li>'Target' ObjectRoot has already been deleted (this does not include
             * marked for destruction!);</li>
             * <li>'Target' ObjectRoot does not belong to any CacheAccess or a different
             * CacheAccess.</li></ul>
             *
             * @param value The new object to which to set the relation or null
             * @throws DDS::PreconditionNotMet if one of the preconditions is not met.
             * @throws DDS::AlreadyDeleted if the Object or it's cache access has
             * already been deleted.
             */
            void
            test::Foo_abstract::set_myBar(
                test::Bar* value) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet);
        -->
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
            <xsl:text>/**</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * Sets a reference to the related '</xsl:text>
            <xsl:value-of select="$attributeName"/>
            <xsl:text>' object. Relationships may only</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * be set between registered objects. If this or one of the other </xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * preconditions is not met, an exception is raised.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> *</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * A PreconditionNotMet is raised if any of the following preconditions is </xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * violated:</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;ul>&lt;li>'Owner' ObjectRoot is not in a (writeable) CacheAccess;&lt;/li></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;li>If the value of the parameter is NIL, but the relation was modeled </xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * as a mandatory relation;&lt;/li></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;li>If the ObjectRoot in the parameter ('target') has different keys </xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * then the 'owner' ObjectRoot and the relation is mapped using so called</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * 'shared' keys;&lt;/li></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;li>'Owner' ObjectRoot is not yet registered;&lt;/li></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;li>'Target' ObjectRoot is not yet registered;&lt;/li></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;li>'Target' ObjectRoot has already been deleted (this does not include </xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * marked for destruction!);&lt;/li></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;li>'Target' ObjectRoot does not belong to any CacheAccess or a different</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * CacheAccess.&lt;/li>&lt;/ul></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> *</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @param value The new object to which to set the relation or null</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @throws DDS::PreconditionNotMet if one of the preconditions is not met.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @throws DDS::AlreadyDeleted if the Object or it's cache access has </xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * already been deleted.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> */</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>void</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>set_</xsl:text>
        <xsl:value-of select="$attributeName"/>
        <xsl:text>(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>    </xsl:text>
        <xsl:value-of select="$returnType"/>
        <xsl:text>* value) THROW_ORB_AND_USER_EXCEPTIONS(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>        DDS::PreconditionNotMet)</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='header'">
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception exception;</xsl:text>
                <xsl:text>    DK_ObjectAdmin* objAdmin = NULL;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_ENTER);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_init(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    if(value)</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    {</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        objAdmin = getObjectRootAdmin(&amp;exception, value, "value");</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    }</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DK_ObjectAdmin_ts_changeRelation(</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        object,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        &amp;exception,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        NULL,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        </xsl:text>
                <xsl:value-of select="$index"/>
                <xsl:text>,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        objAdmin);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_PROPAGATE(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    if(</xsl:text>
                <xsl:value-of select="$prefixedAttributeName"/>
                <xsl:text>)</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    {</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        </xsl:text>
                <xsl:value-of select="$prefixedAttributeName"/>
                <xsl:text>->_remove_ref();</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    }</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    </xsl:text>
                <xsl:value-of select="$prefixedAttributeName"/>
                <xsl:text> = value;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    if(</xsl:text>
                <xsl:value-of select="$prefixedAttributeName"/>
                <xsl:text>)</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    {</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        </xsl:text>
                <xsl:value-of select="$prefixedAttributeName"/>
                <xsl:text>->_add_ref(); </xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    }</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:choose>
                    <xsl:when test="(string-length($relationHasForeignKeys) != 0 and keyMapping) or validityField and not (oid) ">
                        <xsl:text>    /* Change the values in the topic */</xsl:text>
                        <xsl:value-of select="$NL" />
                        <xsl:text>    if(value){</xsl:text>
                        <xsl:value-of select="$NL" />
                        <xsl:for-each select="keyMapping">
                            <xsl:variable name="ownerFieldName" select="@ownerField"/>
                            <xsl:variable name="preFixedOwnerFieldName">
                                <xsl:call-template name="ccpp-name">
                                    <xsl:with-param name="name" select="@ownerField"/>
                                </xsl:call-template>
                            </xsl:variable>
                            <xsl:variable name="isSharedKey">
                                <xsl:for-each select="ancestor::VALUEDEF/DCPSField">
                                    <xsl:variable name="name" select="@name"/>
                                    <xsl:variable name="topic" select="@topic"/>
                                    <xsl:if test="$ownerFieldName=$name">
                                        <xsl:if test="$topicName=$topic">
                                            <xsl:variable name="keyType" select="@keyType"/>
                                            <xsl:if test="$keyType='_SHARED_KEY'">
                                                <xsl:text>yes</xsl:text>
                                            </xsl:if>
                                        </xsl:if>
                                    </xsl:if>
                                </xsl:for-each>
                            </xsl:variable>

                            <xsl:if test="string-length($isSharedKey) = 0 ">
                                <xsl:text>        currentTopic-></xsl:text>
                                <xsl:value-of select="$preFixedOwnerFieldName"/>
                                <xsl:text> = value->get_</xsl:text>
                                <xsl:value-of select="@targetAttributeName"/>
                                <xsl:text>();</xsl:text>
                                <xsl:value-of select="$NL" />
                            </xsl:if>
                        </xsl:for-each>
                        <xsl:if test="validityField">
                            <xsl:text>        currentTopic-></xsl:text>
                            <xsl:value-of select="validityField/@name"/>
                            <xsl:text> = </xsl:text>
                            <xsl:value-of select="validityField/@validValue"/>
                            <xsl:text>;</xsl:text>
                            <xsl:value-of select="$NL" />
                        </xsl:if>
                        <xsl:text>    }</xsl:text>
                        <xsl:value-of select="$NL" />
                        <xsl:if test="validityField">
                            <xsl:text>    else {</xsl:text>
                            <xsl:value-of select="$NL" />
                            <xsl:text>        currentTopic-></xsl:text>
                            <xsl:value-of select="validityField/@name"/>
                            <xsl:text> = </xsl:text>
                            <xsl:value-of select="validityField/@invalidValue"/>
                            <xsl:text>;</xsl:text>
                            <xsl:value-of select="$NL" />
                            <xsl:text>    }</xsl:text>
                            <xsl:value-of select="$NL" />
                        </xsl:if>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:if test="oid">
                            <xsl:text>    if(value){</xsl:text>
                            <xsl:value-of select="$NL"/>
                            <xsl:if test="oid/@nameField">
                                <xsl:text>        LOC_string tmpString = DK_ObjectAdmin_ts_getMainTopicName(objAdmin, &amp;exception, NULL);</xsl:text>
                                <xsl:value-of select="$NL"/>
                                <xsl:text>        DLRL_Exception_PROPAGATE(&amp;exception);</xsl:text>
                                <xsl:value-of select="$NL"/>
                                <xsl:text>        </xsl:text>
                                <xsl:text>currentTopic-></xsl:text>
                                <xsl:value-of select="oid/@nameField"/>
                                <xsl:text> = </xsl:text>
                                <xsl:call-template name="get_corba_module_name"/>
                                <xsl:text>::string_dup(tmpString);</xsl:text>
                                <xsl:value-of select="$NL"/>
                                <xsl:text>        os_free(tmpString);</xsl:text>
                                <xsl:value-of select="$NL"/>
                            </xsl:if>
                            <xsl:value-of select="$NL"/>
                            <xsl:text>        currentTopic-></xsl:text>
                            <xsl:value-of select="oid/@oidField"/>
                            <xsl:text> = value->oid();</xsl:text>
                            <xsl:value-of select="$NL"/>
                            <xsl:text>    } else {</xsl:text>
                            <xsl:value-of select="$NL"/>
                            <xsl:text>        currentTopic-></xsl:text>
                            <xsl:value-of select="oid/@oidField"/>
                            <xsl:text>.systemId = 0;</xsl:text>
                            <xsl:value-of select="$NL"/>
                            <xsl:text>        currentTopic-></xsl:text>
                            <xsl:value-of select="oid/@oidField"/>
                            <xsl:text>.localId = 0;</xsl:text>
                            <xsl:value-of select="$NL"/>
                            <xsl:text>        currentTopic-></xsl:text>
                            <xsl:value-of select="oid/@oidField"/>
                            <xsl:text>.serial = 0;</xsl:text>
                            <xsl:value-of select="$NL"/>
                            <xsl:if test="oid/@nameField">
                                <xsl:text>        </xsl:text>
                                <xsl:text>currentTopic-></xsl:text>
                                <xsl:value-of select="oid/@nameField"/>
                                <xsl:text> = "";</xsl:text>
                                <xsl:value-of select="$NL"/>
                            </xsl:if>
                            <xsl:text>    }</xsl:text>
                            <xsl:value-of select="$NL"/>
                        </xsl:if>
                        <!-- for a singleton, which has no foreign keys or
                             for a relation mapped by shared keys, also execute
                             in oid mapping but although valid input it would be
                             really (emphasis on really) weird if someone uses a
                             seperate validity field when he uses oids as an oid
                             value of (0,0,0) is already able to indicate a null.
                             so we dont optimize this code generated, if we wont
                             spend time in combining the 'if' statements
                          -->
                        <xsl:if test="validityField">
                            <xsl:text>    /* Change the values in the topic */</xsl:text>
                            <xsl:value-of select="$NL" />
                            <xsl:text>    if(value)</xsl:text>
                            <xsl:value-of select="$NL" />
                            <xsl:text>    {</xsl:text>
                            <xsl:value-of select="$NL" />
                            <xsl:text>        currentTopic-></xsl:text>
                            <xsl:value-of select="validityField/@name"/>
                            <xsl:text> = </xsl:text>
                            <xsl:value-of select="validityField/@validValue"/>
                            <xsl:text>;</xsl:text>
                            <xsl:value-of select="$NL" />
                            <xsl:text>    } else {</xsl:text>
                            <xsl:value-of select="$NL" />
                            <xsl:text>        currentTopic-></xsl:text>
                            <xsl:value-of select="validityField/@name"/>
                            <xsl:text> = </xsl:text>
                            <xsl:value-of select="validityField/@invalidValue"/>
                            <xsl:text>;</xsl:text>
                            <xsl:value-of select="$NL" />
                            <xsl:text>    }</xsl:text>
                            <xsl:value-of select="$NL" />
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>

                <xsl:text>    DLRL_Exception_EXIT(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL" />
                <xsl:text>    DLRL_INFO(INF_EXIT);</xsl:text>
                <xsl:value-of select="$NL" />
                <xsl:text>    ccpp_DlrlUtils_us_handleException(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL" />
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL" />
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL" />
    </xsl:template>

    <xsl:template name="generate-multiRelation-operations">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <xsl:variable name="attributeName" select="DECLARATOR/@NAME" />
        <xsl:variable name="index" select="TYPEREF/@INDEX"/>
        <xsl:variable name="type">
            <xsl:call-template name="resolveStatememberIdlType"/>
        </xsl:variable>
        <xsl:variable name="prefixedAttributeName">
            <xsl:call-template name="ccpp-name">
                <xsl:with-param name="name" select="DECLARATOR/@NAME"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:for-each select="//VALUEFORWARDDEF[@NAME=$type]">
            <xsl:variable name="forwardPattern" select="@pattern"/>
            <xsl:variable name="forwardItemType" select="@itemType"/>
            <xsl:variable name="returnType">
                <xsl:call-template name="string-search-replace">
                    <xsl:with-param name="text">
                        <xsl:value-of select="@itemType"/>
                        <xsl:value-of select="@pattern"/>
                    </xsl:with-param>
                    <xsl:with-param name="from" select="'::'"/>
                    <xsl:with-param name="to" select="'::'"/>
                    <xsl:with-param name="prefixKeywords" select="'yes'"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:call-template name="multiRelation__get">
                <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
                <xsl:with-param name="attributeName" select="$attributeName"/>
                <xsl:with-param name="returnType" select="$returnType"/>
                <xsl:with-param name="prefixedAttributeName" select="$prefixedAttributeName"/>
                <xsl:with-param name="white-space" select="$white-space"/>
                <xsl:with-param name="mode" select="$mode"/>
            </xsl:call-template>

            <xsl:call-template name="multiRelation__set">
                <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
                <xsl:with-param name="attributeName" select="$attributeName"/>
                <xsl:with-param name="returnType" select="$returnType"/>
                <xsl:with-param name="forwardPattern" select="$forwardPattern"/>
                <xsl:with-param name="index" select="$index"/>
                <xsl:with-param name="white-space" select="$white-space"/>
                <xsl:with-param name="mode" select="$mode"/>
            </xsl:call-template>
            <xsl:call-template name="multiRelation__is_xxx_modified">
                <xsl:with-param name="classNameFullyQualifiedExceptLast" select="$classNameFullyQualifiedExceptLast"/>
                <xsl:with-param name="attributeName" select="$attributeName"/>
                <xsl:with-param name="white-space" select="$white-space"/>
                <xsl:with-param name="mode" select="$mode"/>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:template>

    <xsl:template name="multiRelation__get">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="attributeName"/>
        <xsl:param name="returnType"/>
        <xsl:param name="prefixedAttributeName"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <!-- Generates the following code for multiRelation 'bars' of type test::BarSet

            test::BarSet*
            test::Foo_abstract::get_bars(
                )
            {
                DLRL_INFO(INF_ENTER);
                bars->_add_ref();
                DLRL_INFO(INF_EXIT);

                return bars;
            }

            or mode = 'header'
            /**
             * Returns a reference to the corresponding 'bars' test.BarSet.
             *
             * @return the corresponding test.BarSet.
             */
            test::BarSet*
            test::Foo_abstract::get_bars(
                );
        -->
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
            <xsl:text>/**</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * Returns a reference to the corresponding '</xsl:text>
            <xsl:value-of select="$attributeName"/>
            <xsl:text>' </xsl:text>
            <xsl:value-of select="$returnType"/>
            <xsl:text>.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> *</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @return the corresponding </xsl:text>
            <xsl:value-of select="$returnType"/>
            <xsl:text>.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> */</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:value-of select="$returnType"/>
        <xsl:text>*</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>get_</xsl:text>
        <xsl:value-of select="$attributeName"/>
        <xsl:text>(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>    )</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='header'">
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_ENTER);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    </xsl:text>
                <xsl:value-of select="$prefixedAttributeName"/>
                <xsl:text>->_add_ref();</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_EXIT);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    return </xsl:text>
                <xsl:value-of select="$prefixedAttributeName"/>
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL"/>
    </xsl:template>

    <xsl:template name="multiRelation__set">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="attributeName"/>
        <xsl:param name="returnType"/>
        <xsl:param name="forwardPattern"/>
        <xsl:param name="index"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>

        <!-- Generates the following code for multiRelation 'bars' of type test::BarSet
            void
            test::Foo_abstract::set_bars(
                test::BarSet* value) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet)
            {
                DLRL_Exception exception;

                DLRL_INFO(INF_ENTER);

                DLRL_Exception_init(&exception);

                DK_ObjectAdmin_ts_changeCollection(
                    object,
                    &exception,
                    NULL,
                    0,
                    value->collection);
                DLRL_Exception_PROPAGATE(&exception);

                DLRL_Exception_EXIT(&exception);
                DLRL_INFO(INF_EXIT);
                ccpp_DlrlUtils_us_handleException(&exception);
            }

            or in header mode:
            /**
             * Sets the content of the object's 'bars' test::BarSet
             * to equal the content of the collection provided as argument.
             * If neccesary this means adding/removing or re-arranging
             * elements in the object's collection in such a manner that the object's
             * collection has the exact same content as the collection provided as
             * argument.
             * A PreconditionNotMet is raised if any of the following preconditions is
             * violated:
             * <ul><li>ObjectRoot is not in a (writeable) cacheaccess;</li>
             * <li>Owner ObjectRoot of the destination collection is not yet
             * registered;</li>
             * <li>Owner ObjectRoot of the source collection is not yet registered;</li>
             * <li>Owner ObjectRoot of the source collection has already been deleted
             * (this does not include marked for destruction!);</li>
             * <li>Owner ObjectRoot of the source collection does not belong to any
             * CacheAccess or a different CacheAccess.</li></ul>
             * A DDS.BadParameter is raised is a NIL value is provided with this
             * function.
             *
             * @param The collection from which to copy the content (!=null)
             * @throws DDS.AlreadyDeleted if any of the involved collections has
             * already been deleted.
             * @throws DDS.PreconditionNotMet if any of the preconditions are not met.
             * @throws DDS.BadParameter if the val parameter was a NIL value.
             */
            void
            set_bars(
                test::BarSet* value) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet);
        -->
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
            <xsl:text>/**</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * Sets the content of the object's 'bars' test::BarSet</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * to equal the content of the collection provided as argument.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * If neccesary this means adding/removing or re-arranging</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * elements in the object's collection in such a manner that the object's</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * collection has the exact same content as the collection provided as</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * argument.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * A PreconditionNotMet is raised if any of the following preconditions is</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * violated:</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;ul>&lt;li>ObjectRoot is not in a (writeable) cacheaccess;&lt;/li></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;li>Owner ObjectRoot of the destination collection is not yet</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * registered;&lt;/li></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;li>Owner ObjectRoot of the source collection is not yet registered;&lt;/li></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;li>Owner ObjectRoot of the source collection has already been deleted</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * (this does not include marked for destruction!);&lt;/li></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * &lt;li>Owner ObjectRoot of the source collection does not belong to any</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * CacheAccess or a different CacheAccess.&lt;/li>&lt;/ul></xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * A DDS.BadParameter is raised is a NIL value is provided with this</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * function.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> *</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @param The collection from which to copy the content (!=null)</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @throws DDS.AlreadyDeleted if any of the involved collections has</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * already been deleted.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @throws DDS.PreconditionNotMet if any of the preconditions are not met.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> * @throws DDS.BadParameter if the val parameter was a NIL value.</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
            <xsl:text> */</xsl:text>
            <xsl:value-of select="$NL"/>
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>void</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>set_</xsl:text>
        <xsl:value-of select="$attributeName"/>
        <xsl:text>(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>    </xsl:text>
        <xsl:value-of select="$returnType"/>
        <xsl:text>* value) THROW_ORB_AND_USER_EXCEPTIONS(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>        DDS::PreconditionNotMet)</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='header'">
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception exception;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_ENTER);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_init(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DK_ObjectAdmin_ts_changeCollection(</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        object,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        &amp;exception,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        NULL,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>        </xsl:text>
                <xsl:value-of select="$index"/>
                <xsl:text>,</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:choose>
                    <xsl:when test="$forwardPattern='StrMap'">
                        <xsl:text>        reinterpret_cast&lt;DK_Collection*>(getStrMapAdmin(&amp;exception, value, "value")));</xsl:text>
                    </xsl:when>
                    <xsl:when test="$forwardPattern='IntMap'">
                        <xsl:text>        reinterpret_cast&lt;DK_Collection*>(getIntMapAdmin(&amp;exception, value, "value")));</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>        reinterpret_cast&lt;DK_Collection*>(getSetAdmin(&amp;exception, value, "value")));</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_PROPAGATE(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_Exception_EXIT(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_EXIT);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    ccpp_DlrlUtils_us_handleException(&amp;exception);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL"/>
    </xsl:template>

    <xsl:template name ="multiRelation__is_xxx_modified">
        <xsl:param name="classNameFullyQualifiedExceptLast"/>
        <xsl:param name="attributeName"/>
        <xsl:param name="white-space"/>
        <xsl:param name="mode"/>
        <!--The following code is generated by this template for example type 'Foo' defined in module 'test'
            with multiRelation 'bars':

            CORBA::Boolean
            test::Foo_abstract::is_bars_modified(
                DDS::ObjectScope scope)
            {
                DLRL_INFO(INF_ENTER);

                /* not supported for relations */

                DLRL_INFO(INF_EXIT);
                return FALSE;
            }

        -->
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:call-template name="get_corba_module_name"/>
        <xsl:text>::Boolean</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:choose>
            <xsl:when test="$mode='ccpp'">
                <xsl:value-of select="$classNameFullyQualifiedExceptLast"/>
                <xsl:text>_abstract::</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$white-space"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>is_</xsl:text>
        <xsl:value-of select="$attributeName"/>
        <xsl:text>_modified(</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:if test="$mode='header'">
            <xsl:value-of select="$white-space"/>
        </xsl:if>
        <xsl:text>    DDS::ObjectScope scope)</xsl:text>
        <xsl:choose>
            <xsl:when test="$mode='header'">
                <xsl:text>;</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$NL"/>
                <xsl:text>{</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_ENTER);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    /* not supported for relations */</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:value-of select="$NL"/>
                <xsl:text>    DLRL_INFO(INF_EXIT);</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>    return false;</xsl:text>
                <xsl:value-of select="$NL"/>
                <xsl:text>}</xsl:text>
                <xsl:value-of select="$NL"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$NL"/>
    </xsl:template>

    <!--A setter for a mono attribute must only be generated if the dcps field doesn't
        represent a foreign key -->
    <xsl:template name="must-monoAttribute-setter-be-generated">
        <xsl:param name="valueFieldName"/>
        <xsl:param name="topicName"/>

        <xsl:if test="string-length($valueFieldName) != 0">
            <xsl:for-each select="ancestor::node()/DCPSField">
                <xsl:variable name="name" select="@name"/>
                <xsl:variable name="topic" select="@topic"/>

                <xsl:if test="$name=$valueFieldName">
                    <xsl:if test="$topicName=$topic">
                        <xsl:variable name="keyType" select="@keyType"/>
                        <xsl:variable name="immutable" select="@immutable"/>

                        <xsl:choose>
                            <xsl:when test="$immutable='true'">
                                <xsl:text>no</xsl:text>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:if test="$keyType='_FOREIGN_KEY'">
                                    <xsl:text>no</xsl:text>
                                </xsl:if>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:if>
                </xsl:if>
            </xsl:for-each>
        </xsl:if>
    </xsl:template>

    <xsl:template name="hasForeignKeysForMonoRelation">
        <xsl:param name="topicName"/>

        <xsl:for-each select="keyDescription/keyField">
            <xsl:variable name="dcpsFieldName" select="."/>

            <xsl:if test="string-length($dcpsFieldName) != 0">
                <xsl:for-each select="ancestor::node()/DCPSField">
                    <xsl:variable name="name" select="@name"/>
                    <xsl:variable name="topic" select="@topic"/>

                    <xsl:if test="$name=$dcpsFieldName">
                        <xsl:if test="$topicName=$topic">
                            <xsl:variable name="keyType" select="@keyType"/>

                            <xsl:if test="$keyType='_FOREIGN_KEY'">
                                <xsl:text>yes</xsl:text>
                            </xsl:if>
                        </xsl:if>
                    </xsl:if>
                </xsl:for-each>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>

</xsl:stylesheet>
