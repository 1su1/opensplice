<?xml version="1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

    <!-- That's standard for us -->
    <xsl:output method="text"/>

    <xsl:template name="copyright-notice">
        <xsl:text>/******************************************************************************</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:text> ***                     Generated code: DO NOT EDIT!!!                     ***</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:text> ***        Generated by the OpenSplice DLRL Code Generator(OSPLDCG)        ***</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:text> ***             OpenSplice (c) is a product of PrismTech Ltd.              ***</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:text> ***                 Visit our website at www.prismtech.com                 ***</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:text> ***                                                                        ***</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:text> ***         ----------------------OpenSplice----------------------         ***</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:text> ***        |  Delivering the right information to the right place |        ***</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:text> ***        |   at the right time for real-time application users  |        ***</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:text> ***         ------------------------------------------------------         ***</xsl:text>
        <xsl:value-of select="$NL"/>
        <xsl:text> ******************************************************************************/</xsl:text>
        <xsl:value-of select="$NL"/>
    </xsl:template>

    <!-- convenient string constants -->
    <xsl:variable name="NL"> <!-- a newline character -->
        <xsl:text>&#xA;</xsl:text>
    </xsl:variable>

    <xsl:template name="statemember-visibility">
        <xsl:choose>
            <xsl:when test="@PUBLIC = 'true'">public </xsl:when>
            <xsl:otherwise>protected </xsl:otherwise>
        </xsl:choose>
    </xsl:template>


    <!-- Templates used in multiple XSL files -->
    <xsl:template name="determineMonoAttributeImmutabilityFromWithinStateMemberElement">
        <xsl:param name="dcpsFieldName"/>
        <xsl:param name="topicName"/>
        <xsl:param name="trueVal"/>
        <xsl:param name="falseVal"/>

        <xsl:for-each select="ancestor::node()/DCPSField">
            <xsl:variable name="name" select="@name"/>
            <xsl:variable name="topic" select="@topic"/>
            <xsl:if test="$name=$dcpsFieldName">
                <xsl:if test="$topicName=$topic">
                    <xsl:variable name="keyType" select="@keyType"/>
                    <xsl:choose>
                        <xsl:when test="$keyType='_KEY' or $keyType='_SHARED_KEY'">
                            <xsl:value-of select="$trueVal"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$falseVal"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:if>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>

    <xsl:template name="determineMultiRelationBaseType">
        <xsl:param name="pattern"/>

        <xsl:if test="$pattern='Set'">
            <xsl:text>_SET</xsl:text>
        </xsl:if>
        <xsl:if test="$pattern='IntMap'">
            <xsl:text>_INT_MAP</xsl:text>
        </xsl:if>
        <xsl:if test="$pattern='StrMap'">
            <xsl:text>_STR_MAP</xsl:text>
        </xsl:if>
    </xsl:template>

    <xsl:template name="does-valuedef-inherit-from-objectroot-and-is-not-included">
        <xsl:choose>
            <xsl:when test="@fromIncludedIdl='false'">
                <xsl:if test="VALUEINHERITS">
                    <xsl:variable name="parentName" select="VALUEINHERITS/@NAME"/>
                    <xsl:choose>
                        <xsl:when test="$parentName='DDS::ObjectRoot'">
                            <xsl:text>true</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:for-each select="//VALUEDEF[@NAME=$parentName]">
                                <xsl:call-template name="does-valuedef-inherit-from-objectroot-and-is-not-included"/>
                            </xsl:for-each>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:if>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>false</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- this template returns the idl type name. It will automatically traverse any sequence it finds
        to get to the correct TYPEREF element. It will also resolve any typedef if applicable.
    -->
    <xsl:template name="resolveStatememberIdlType">

        <xsl:variable name="idlType" select="TYPEREF/@TYPE"/>

        <xsl:choose>
            <!-- if it's a sequence we must recurse into the element
                structure to find the eventual TYPEREF element
            -->
            <xsl:when test="SEQUENCE">
                <xsl:for-each select="SEQUENCE">
                    <xsl:call-template name="resolveStatememberIdlType"/>
                </xsl:for-each>
            </xsl:when>
            <!-- maybe it's a string, wstring or a simple type. Check that because then we dont have to
                evaluate all typedefs and that could save us some time.
            -->
            <xsl:when test="STRING">
                <xsl:text>STRING</xsl:text>
            </xsl:when>
            <xsl:when test="WSTRING">
                <xsl:text>WSTRING</xsl:text>
            </xsl:when>
            <xsl:when test="$idlType='boolean'              or $idlType='char'          or $idlType='float' or
                            $idlType='double'               or $idlType='short'         or $idlType='unsigned short' or
                            $idlType='long'                 or $idlType='unsigned long' or $idlType='long long' or
                            $idlType='unsigned long long'   or $idlType='octet'         or $idlType='any' or
                            $idlType='long double'          or $idlType='wchar'">
                <xsl:value-of select="$idlType"/>
            </xsl:when>
            <xsl:otherwise>
                <!-- ok, the type is a scoped name, first check if it's a typedef -->
                <xsl:variable name="typedefElement" select="//TYPEDEF[$idlType=DECLARATOR/@NAME]"/>
                <xsl:choose>
                    <!-- todo CPP001 verify such a test actually works-->
                    <!-- maybe it's a typedef, if so recurse further into the structure -->
                    <xsl:when test="$typedefElement">
                        <xsl:for-each select="$typedefElement"><!-- we must enter the element...-->
                            <xsl:call-template name="resolveStatememberIdlType"/>
                        </xsl:for-each>
                    </xsl:when>
                    <!-- It's not a typedef, so its an enum, struct, union, valuetype, forward valuetype, etc.
                        we can just return that name.
                    -->
                    <xsl:otherwise>
                        <xsl:value-of select="$idlType"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- this template will get array brackets with length filled in (i.e., [2])
         or without length, thus plain brackets (i.e., []) or count the number of
         brackets total and return that number. Any typedefs will also be resolved and
         arrays/sequences defined there also taken into account. Orderning is as follows
         1) arrays defined at current level
         2) sequences defined at current level
         3) resolve typedefs at current level
         3.1) arrays defined in the typedef at that level
         3.2) sequences defined in the typedef at that level
         3.3) repeat step 3 if applicable
         orderning is especially important during the 'brackt-value' action. For other
         actions it isnt that important as one can not distinguish between the results.
      -->
    <xsl:template name="get-array-brackets">
        <xsl:param name="action"/><!-- bracket-only | bracket-value | count -->
        <xsl:param name="userData"/><!-- used when action is 'count' -->

        <xsl:variable name="nrOfArrays" select="count(DECLARATOR/ARRAY)"/>

        <!-- First process the array brackets, if the action is 'count' then we dont have to do anything here
             as we will use the 'nrOfArrays' variable for that action type later on -->
        <xsl:if test="not ($action='count')">
            <xsl:for-each select="DECLARATOR/ARRAY">
                <xsl:choose>
                    <xsl:when test="$action='bracket-value'">
                        <xsl:text>[</xsl:text>
                        <xsl:value-of select="@LENGTH"/>
                        <xsl:text>]</xsl:text>
                    </xsl:when>
                    <xsl:when test="$action='bracket-only'">
                        <xsl:text>[]</xsl:text>
                    </xsl:when>
                </xsl:choose>
            </xsl:for-each>
        </xsl:if>

        <xsl:variable name="sequenceAndTypeDefBrackets">
            <xsl:call-template name="get-array-brackets_SEQUENCE_TYPEDEF">
                <xsl:with-param name="action" select="$action"/>
                <xsl:with-param name="userData">0</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$action='count'">
                <xsl:choose>
                    <xsl:when test="string-length($sequenceAndTypeDefBrackets) !=0">
                        <xsl:value-of select="$userData + $nrOfArrays + $sequenceAndTypeDefBrackets"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$userData + $nrOfArrays"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$sequenceAndTypeDefBrackets"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="get-array-brackets_TYPEDEF">
        <xsl:param name="action"/><!-- bracket-only | bracket-value | count -->
        <xsl:param name="userData"/><!-- used when action is 'count' -->
        <xsl:param name="type"/>

        <xsl:for-each select="//TYPEDEF[$type=DECLARATOR/@NAME]">
            <xsl:call-template name="get-array-brackets">
                <xsl:with-param name="action" select="$action"/>
                <xsl:with-param name="userData" select="$userData"/>
            </xsl:call-template>
        </xsl:for-each>
    </xsl:template>

    <xsl:template name="get-array-brackets_SEQUENCE_TYPEDEF">
        <xsl:param name="action"/><!-- bracket-only | bracket-value | count -->
        <xsl:param name="userData"/><!-- used when action is 'count' -->

        <!-- now process all sequences -->
        <xsl:for-each select="SEQUENCE">
            <xsl:choose>
                <xsl:when test="$action='bracket-value'">
                    <xsl:text>[0]</xsl:text>
                    <xsl:call-template name="get-array-brackets_SEQUENCE_TYPEDEF">
                        <xsl:with-param name="action" select="$action"/>
                        <xsl:with-param name="userData" select="$userData"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="$action='count'">
                    <xsl:call-template name="get-array-brackets_SEQUENCE_TYPEDEF">
                        <xsl:with-param name="action" select="$action"/>
                        <xsl:with-param name="userData" select="$userData+1"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="$action='bracket-only'">
                    <xsl:text>[]</xsl:text>
                    <xsl:call-template name="get-array-brackets_SEQUENCE_TYPEDEF">
                        <xsl:with-param name="action" select="$action"/>
                        <xsl:with-param name="userData" select="$userData"/>
                    </xsl:call-template>
                </xsl:when>
            </xsl:choose>
        </xsl:for-each>
        <xsl:if test="not (SEQUENCE)">
            <xsl:variable name="type" select="TYPEREF/@TYPE"/>
            <xsl:variable name="typedefBrackets">
                <xsl:call-template name="get-array-brackets_TYPEDEF">
                    <xsl:with-param name="action" select="$action"/><!-- bracket-only | bracket-value | count -->
                    <xsl:with-param name="userData">0</xsl:with-param><!-- used when action is 'count' -->
                    <xsl:with-param name="type" select="$type"/>
                </xsl:call-template>
            </xsl:variable>
            <xsl:if test="$action='count'">
                <xsl:if test="string-length($typedefBrackets) != 0">
                    <xsl:value-of select="$userData + $typedefBrackets"/>
                </xsl:if>
                <xsl:if test="string-length($typedefBrackets) = 0">
                    <xsl:value-of select="$userData"/>
                </xsl:if>
            </xsl:if>
            <xsl:if test="not ($action='count')">
                <xsl:value-of select="$typedefBrackets"/>
            </xsl:if>
        </xsl:if>
    </xsl:template>

    <!-- This templare return the idl type spec id. This is either a SEQUENCE or STRING or
        WSTRING or SIMPLE or ENUM or STRUCT or UNION or UNKNOWN (ie any type not yet supported/relevant)
        Any typedefs encountered are automatically resolved to their final type.
    -->
    <xsl:template name="get-idl-type-spec-id">

        <xsl:variable name="idlType" select="TYPEREF/@TYPE"/>

        <xsl:choose>
            <!-- if it's a sequence we must recurse into the element
                structure to find the eventual TYPEREF element
            -->
            <xsl:when test="SEQUENCE and SEQUENCE/@VALUE=0">
                <xsl:text>UNBOUNDED_SEQUENCE</xsl:text>
            </xsl:when>
            <xsl:when test="SEQUENCE and not (SEQUENCE/@VALUE=0)">
                <xsl:text>BOUNDED_SEQUENCE</xsl:text>
            </xsl:when>
            <!-- maybe it's a string, wstring or a simple type. Check that because then we dont have to
                evaluate all typedefs and that could save us some time.
            -->
            <xsl:when test="STRING">
                <xsl:text>STRING</xsl:text>
            </xsl:when>
            <xsl:when test="WSTRING">
                <xsl:text>WSTRING</xsl:text>
            </xsl:when>
            <xsl:when test="DECLARATOR/ARRAY">
                <xsl:text>ARRAY</xsl:text>
            </xsl:when>
            <xsl:when test="$idlType='boolean'              or $idlType='char'          or $idlType='float' or
                            $idlType='double'               or $idlType='short'         or $idlType='unsigned short' or
                            $idlType='long'                 or $idlType='unsigned long' or $idlType='long long' or
                            $idlType='unsigned long long'   or $idlType='octet'         or
                            $idlType='long double'          or $idlType='wchar'">
                <xsl:text>SIMPLE</xsl:text>
            </xsl:when>
            <xsl:when test="$idlType='any'">
                <xsl:text>ANY</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <!-- ok, the type is a scoped name, first check if it's a typedef -->
                <xsl:variable name="typedefElement" select="//TYPEDEF[$idlType=DECLARATOR/@NAME]"/>
                <xsl:choose>
                    <!-- todo CPP001 verify such a test actually works-->
                    <!-- maybe it's a typedef, if so recurse further into the structure -->
                    <xsl:when test="$typedefElement">
                        <xsl:for-each select="$typedefElement"><!-- we must enter the element...-->
                            <xsl:call-template name="get-idl-type-spec-id"/>
                        </xsl:for-each>
                    </xsl:when>
                    <!-- It's not a typedef, so its an enum, struct, union, valuetype, forward valuetype, etc.
                        we can just return that name.
                    -->
                    <xsl:otherwise>
                        <xsl:variable name="enumElement" select="//ENUM[$idlType=@NAME]"/>
                        <xsl:choose>
                            <xsl:when test="$enumElement">
                                <xsl:text>ENUM</xsl:text>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:variable name="structElement" select="//STRUCT[$idlType=@NAME]"/>
                                <xsl:choose>
                                    <xsl:when test="$structElement">
                                        <xsl:text>STRUCT</xsl:text>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:variable name="unionElement" select="//UNION[$idlType=@NAME]"/>
                                        <xsl:choose>
                                            <xsl:when test="$unionElement">
                                                <xsl:text>UNION</xsl:text>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:text>UNKNOWN</xsl:text>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

</xsl:stylesheet>
