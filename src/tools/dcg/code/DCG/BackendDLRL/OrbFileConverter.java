/*
 *                         OpenSplice DDS
 *
 *   This software and documentation are Copyright 2006 to 2013 PrismTech
 *   Limited and its licensees. All rights reserved. See file:
 *
 *                     $OSPL_HOME/LICENSE
 *
 *   for full copyright notice and license terms.
 *
 */
package DCG.BackendDLRL;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.File;
import java.io.IOException;
import java.util.Vector;
import java.util.StringTokenizer;
import DCG.Core.MainModel;
import DCG.DCGUtilities.*;
import org.w3c.dom.Element;
import org.w3c.dom.Document;
import org.openorb.compiler.idl.reflect.*;
import org.openorb.compiler.object.*;

public class OrbFileConverter {

    /* various IDL keywords defined as constants for easy reference. Obvious I would say. */
    public static final String MODULE = "module";
    public static final String VALUETYPE = "valuetype";
    public static final String BRACE_OPEN = "{";
    public static final String BRACE_CLOSE = "}";
    public static final String DLRL_BASE_CLASS = "DDS::ObjectRoot";
    public static final String PUBLIC = "public";
    public static final String PRIVATE = "private";
    public static final String SEMI_COLON = ";";
    public static final String SLASH = "/";
    public static final String STAR = "*";

    /* The states of the 'main' idl processing state machine */
    /* state 'SCAN' means: look for valuetypes, if we detect a valuetype we will move to the VALUETYPE_DETECT state*/
    public static final int SCAN = 0;
    /* state 'VALUETYPE_DETECT' means: We found a valuetype, but we have yet to determine if its a DLRL valuetype.
     * if we detect it's not a dlrl valuetype then we revert back to the SCAN state, otherwise we go to the
     * DLRL_VALUETYPE_DETECT state.
     */
    public static final int VALUETYPE_DETECT = 1;
    /* state 'DLRL_VALUETYPE_DETECT' means: We have determined that the valuetype we found earlier is actually a
     * DLRL valuetype. We can now start scanning for statemembers to convert. Once we find a (public) statemember we
     * will move to the STATEMEMBER_START state. However if we detect a (private) statemember we will move to the
     * STATEMEMBER_DISCARD state. And finally if we detect the end brace of the valuetype we will go back to the SCAN
     * state.
     */
    public static final int DLRL_VALUETYPE_DETECT = 2;
    /* state 'STATEMEMBER_START' means: we have found a (public) statemember which we need to convert to operations
     * we can now collect tokens until we reach the end of the statemember (i.e. encounter a ';' token). Once we
     * locate that token we will simply output the convert statemember info. And once completed we will move back
     * to the DLRL_VALUETYPE_DETECT state.
     */
    public static final int STATEMEMBER_START = 3;
    /* state 'STATEMEMBER_DISCARD' means: we found a statemember inside a dlrl valuetype, but it has a private accessor
     * this means that it should not be in the public header file generated by the orb so we will discard the entire
     * statemember. Once we detected that we reached the end of the statemember definition we will move back to the
     * DLRL_VALUETYPE_DETECT state.
     */
    public static final int STATEMEMBER_DISCARD = 4;


    public static final int MODULE_DETECT = 5;
    /* This variable contains thew current 'main' idl processing state. We start with the 'SCAN' state. */
    private int state = SCAN;

    /* A 'secondary' state machine (comments state machine) intertwines with the main statemachine. We need to filter
     * out any comments as they are irrelevant to the eventual file generate by the orb and comments can be nasty as
     * they may contain tokens the 'main' state machine triggers on, causing major issues. And defining a secondary
     * statemachine to filter out comments before consdidering such tokens for the main statemachine makes the main
     * statemachine much simpler
     */
    /* state 'NO_COMMENT' means: This is a start state of the 'comments' state machine. It indicates that we haven't
     * detected any comments and everything is ok in that regard.
     */
    public static final int NO_COMMENT = 0;
    /* state 'COMMENT_BEGIN' means: We have detected a slash token, this means we might be about to encounter comments
     * which we need to filter out! However the slash token may also be used inside expressions, so we can't be sure.
     * from this start we can reach the SINGLE_LINE_COMMENT or MULTI_LINE_COMMENT or revert back to the NO_COMMENT state
     */
    public static final int COMMENT_BEGIN = 1;
    /* state 'SINGLE_LINE_COMMENT' means: We have detected a second slash token and are now processing tokens that
     * can be seen as comments. However once we start reading a new line then we must6 revert back to the NO_COMMENT
     * state as a double slash comment only lasts one line. From this state we can only reach the NO_COMMENT state
     * again.
     */
    public static final int SINGLE_LINE_COMMENT = 2;
    /* state 'MULTI_LINE_COMMENT' means: We have detected a star following a slash, so this means we might encounter
     * multiple lines of comments. But it may also be that this comment is ended on the same line that it was found
     * and that 'normal' idl code is following it once the end of the comment is reached. From this state we can only
     * reach the MULTI_LINE_COMMENT_END_BEGIN state.
     */
    public static final int MULTI_LINE_COMMENT = 3;
    /* state 'MULTI_LINE_COMMENT_END_BEGIN' means: This means we have detected a star and we might be near the end of
     * the multi line comment, however we can't be sure until we detect a slash token directly following the star token.
     * if the token following the star token is not a slash token then we move back to the MULTI_LINE_COMMENT state. If
     * we did detect the slash token we'll go to the NO_COMMENT state again
     */
    public static final int MULTI_LINE_COMMENT_END_BEGIN = 4;
    /* This variable contains the current 'comments' idl processing state. We start with the 'NO_COMMENT' state. */
    private int COMMENT_STATE = NO_COMMENT;

    /* The reader and writer for the input idl file */
    private BufferedReader in = null;
    private BufferedWriter out = null;
    /* The delimiters to tokenize individual lines in the file with */
    private final String IDL_DELIM = ";{}\t/* ";

    /* The outputdirectory File and output File objects.. require no explanation i assume */
    private File outputDirectory = null;
    private File outputFile = null;
    private MainModel model = null;
    private Document rootXML;

    /* increased with a '{' is enountered and decreased when a '}' is encountered, easy peasy lemon squizy*/
    private long nrOfBraces = 0;
    /* each time a module is detected the name of the module is inserted here, when the module is closed it's
     * removed again, Strings are contained
     */
    private Vector moduleNames = new Vector();
    /* This vector contains Longs, each long is 'virtually' linked to a name in the 'moduleNames' vector. i.e.,
     * the long at index 0 here corresponds to the module name at index 0 in the 'moduleNames' vector.
     * Each time a module is opened it's name is stored and also the current 'nrOfBraces' value is stored. So that
     * when we encounter a closing brace '{' we can check if thst closing brace actually closes a module and if it does
     * remove that module and brace count!
     */
    private Vector moduleBraceCount = new Vector();

    private String valuetypeName = null;//stores the name of the current valuetype being processed
    private boolean statememberIsPublic = true;
    private Vector rootDlrlIdl;

    /* This variable is used when we are processing a DLRL valuetype. It might be that a struct or union or something
     * else is defined within the scope of the valuetype. That legal in IDL but it will have as a result that we'll
     * encounter multiple (opening and closing) braces in the valuetype. And the only way we know we have processed the
     * entire valuetype is when we encounter it's closing brace, thus we will count the number of braces we encounter
     * while processing a valuetype, when it reaches zero we will know the valuetype is closed and we can move onto the
     * next.
     */
    private int valuetypeBraceCount = 0;

    /* private constructor, disallow constructor without the required params */
    private OrbFileConverter(){}

    public OrbFileConverter(
        MainModel model,
        Document rootXML,
        Vector rootDlrlIdl)
    {
        this.model = model;
        this.rootXML = rootXML;
        this.rootDlrlIdl = rootDlrlIdl;
    }

    public void
    convertDlrlIdl(
        File dlrlIdl) throws Exception, IOException
    {
        String line;

        /* where did the user want the output again? */
        outputDirectory = model.getOutputDirectoryPath();
        /* we are gonna generate a temp file just to supply the orb with the correct info, so lets place it in
         * a temporary directory as we need to use the same file name!
         */
        outputDirectory = new File(outputDirectory.getAbsolutePath()+File.separator+"ptdlrltmp");
        /* our temp directory might now exist, so lets create it. if it did exist, then this is a no-op */
        outputDirectory.mkdirs();
        /* Now lets set the correct output file name */
        outputFile = new File(outputDirectory+File.separator+dlrlIdl.getName());
        /* check if the output file exists, if it does and the user wants verboise messages then we will warn
         * that we are going to overwrite the file. We always overwrite as the tmp directory should be unique enough
         * and the file left is probably left from an earlier run with verbose on (file doesnt get deleted in that case)
         */
        if(outputFile.exists() && model.getVerbose())
        {
            System.out.println("- Warning: Overwriting file: "+ outputFile.getAbsolutePath());
        }
        try
        {
            /* now create the file reader for the original file and the file writer for the altered orb ready file */
            in = new BufferedReader(new FileReader(dlrlIdl));
            out = new BufferedWriter(new FileWriter(outputFile));
            /* now we are going to process the original idl file line for line and take the neccesary actions as detailed
             * in processLine.
             */
            while(in.ready())
            {
                line = in.readLine();
                processLine(line);
                out.newLine();
            }
            /* lets not forget to close the output streams! */
            in.close();
            in = null;
            out.close();
            out = null;
        } catch (Exception e)
        {
            /* if an exception occured we need to make sure that we dont left the in/out streams open! */
            if(in != null)
            {
                in.close();
                in = null;
            }
            if(out != null)
            {
                out.close();
                out = null;
            }
            throw e;
        }
    }

    public File getOutputFile(
        )
    {
        return outputFile;
    }

    public void
    deleteGeneratedFile(
        ) throws Exception
    {
        /* delete the output file, if any */
        if(outputFile != null)
        {
            if (!outputFile.delete() && model.getVerbose())
            {
                System.out.println("- Notification: Could not delete file "+ outputFile.getAbsolutePath());
            }
            outputFile = null;

        }
        /* try to delete the output directory, it will only succeed if the directory is actually empty */
        if(outputDirectory != null)
        {
            if (!outputDirectory.delete() && model.getVerbose()){
                System.out.println("- Notification: Could not delete directory "+ outputDirectory.getAbsolutePath());
            }
        }
    }

    /* Main operation. contains the state machines. It will analyze each line read from the input file and determine
     * the correct course of action.
     */
    private final void
    processLine(
        String line) throws Exception
    {
        StringTokenizer tokenizer;
        Vector statememberTokens;

        statememberTokens = new Vector();

        /* use tokenizer instead of split cos we want the tokens themselves returned as well! */
        tokenizer = new StringTokenizer(line, IDL_DELIM, true);

        while(tokenizer.hasMoreTokens())
        {
            String token;
            boolean writeToken;

            token = tokenizer.nextToken();

            /* must filter out comments first! */
            switch (COMMENT_STATE)
            {
            case NO_COMMENT:
                if(token.equals(SLASH))
                {
                    COMMENT_STATE = COMMENT_BEGIN;
                    token = null;
                }
                break;
            case COMMENT_BEGIN:
                if(token.equals(SLASH))
                {
                    COMMENT_STATE = SINGLE_LINE_COMMENT;
                    token = null;
                } else if(token.equals(STAR))
                {
                    COMMENT_STATE = MULTI_LINE_COMMENT;
                    token = null;
                } else
                {
                    token = SLASH+token;//need to restore the '/' token again, wasnt part of a comment thing anyway!
                    COMMENT_STATE = NO_COMMENT;
                }
                break;
            case SINGLE_LINE_COMMENT:
                token = null;
                break;
            case MULTI_LINE_COMMENT:
                if(token.equals(STAR))
                {
                    COMMENT_STATE = MULTI_LINE_COMMENT_END_BEGIN;
                }
                token = null;
                break;
            case MULTI_LINE_COMMENT_END_BEGIN:
                if(token.equals(SLASH))
                {
                    COMMENT_STATE = NO_COMMENT;
                } else
                {
                    /* false alarm, was no end of the multi line comment, so go back to the normal multi line comment
                     * state
                     */
                    COMMENT_STATE = MULTI_LINE_COMMENT;
                }
                token = null;
                break;
            }
            /* now process the token if it was not 'eaten' by the comments part */
            if(token != null)
            {
                if(token.equals(BRACE_OPEN))
                {
                    nrOfBraces++;
                } else if(token.equals(BRACE_CLOSE))
                {
                    nrOfBraces--;
                    if(moduleBraceCount.size() > 0)
                    {
                        Long tmpCount = (Long)moduleBraceCount.get(moduleBraceCount.size()-1);
                        if(nrOfBraces == tmpCount.longValue())
                        {
                            moduleBraceCount.remove(moduleBraceCount.size()-1);
                            moduleNames.remove(moduleNames.size()-1);
                        }
                    }
                }
                writeToken = true;
                switch (state)
                {
                case SCAN:
                    if(token.equals(VALUETYPE))
                    {
                        state = VALUETYPE_DETECT;
                    } else if(token.equals(MODULE))
                    {
                        state = MODULE_DETECT;
                    }
                    break;
                case MODULE_DETECT:
                    if(token.trim().length() > 0)/* ignore whitespaces and stuff */
                    {
                        moduleNames.add(token);
                        moduleBraceCount.add(new Long(nrOfBraces));
                        state = SCAN;
                    }
                    break;
                case VALUETYPE_DETECT:
                    if(valuetypeName == null && token.trim().length() != 0)
                    {
                        valuetypeName = "";
                        for(int i = 0; i < moduleNames.size(); i++)
                        {
                            valuetypeName = valuetypeName + moduleNames.get(i) + "::";
                        }
                        valuetypeName = valuetypeName + token;
                    }
                    if(token.equals(BRACE_OPEN) || token.equals(SEMI_COLON))
                    {
                        state = SCAN;
                        valuetypeName = null;
                    } else if(token.contains(DLRL_BASE_CLASS))
                    {
                        state = DLRL_VALUETYPE_DETECT;
                    }
                    break;
                case DLRL_VALUETYPE_DETECT:
                    if(token.equals(BRACE_OPEN))
                    {
                        valuetypeBraceCount++;
                    } else if(token.equals(BRACE_CLOSE))
                    {
                        valuetypeBraceCount--;
                        if(valuetypeBraceCount == 0)
                        {
                            valuetypeName = null;
                            state = SCAN;
                        }
                    } else if(token.equals(PUBLIC))
                    {
                        statememberIsPublic = true;
                        state = STATEMEMBER_START;
                        writeToken = false;
                    } else if (token.equals(PRIVATE))
                    {
                        statememberIsPublic = false;
                        state = STATEMEMBER_START;
                        writeToken = false;
                    }
                    break;
                case STATEMEMBER_START:
                    if(token.equals(SEMI_COLON))
                    {
                        transformStatemember(statememberTokens);
                        statememberTokens.clear();
                        writeToken = false;
                        state = DLRL_VALUETYPE_DETECT;
                    } else
                    {
                        statememberTokens.add(token);
                        writeToken = false;
                    }
                    break;
               /* case STATEMEMBER_DISCARD:
                    if(token.equals(SEMI_COLON))
                    {
                        writeToken = false;
                        state = DLRL_VALUETYPE_DETECT;
                    } else
                    {
                        writeToken = false;
                    }
                    break;*/
                }

                if(writeToken)
                {
                    String tdef = null;
                    if(token.trim().length() != 0)
                    {

                        if(state == VALUETYPE_DETECT && wroteVal)
                        {
                            String tmp;
                            tmp = "";
                            for(int i = 0; i < moduleNames.size(); i++)
                            {
                                tmp = tmp + moduleNames.get(i) + "::";
                            }
                            tmp = tmp + token;
                            tdef = getTemplateDefComposedName(tmp);
                            if(tdef != null)
                            {
                                String[] tdefArray;
                                tdefArray = tdef.split("::");
                                tdef = tdefArray[tdefArray.length-1];
                            }
                        }
                        if(token.equals("valuetype"))
                        {
                            wroteVal = true;
                        } else
                        {
                            wroteVal = false;
                        }
                    }
                    if(tdef == null || tdef.equals(token))
                    {
                        out.write(token);
                    } else
                    {
                        out.write(tdef);
                        out.write(";\ntypedef "+tdef+" "+token);
                    }
                }
            }
        }
        /* perform some clean up after processing all tokens */
        if(COMMENT_STATE == SINGLE_LINE_COMMENT)
        {
            /* single line comments end at the end of the line, so reset to no comment state */
            COMMENT_STATE = NO_COMMENT;
        } else if(COMMENT_STATE == COMMENT_BEGIN)
        {
            /* if we detected a '/' char but after reaching the end of the line we didnt find a matching '/' or
             * '*' char then we need to write the '/' to the file output anyway!
             */
            out.write(SLASH);
            COMMENT_STATE = NO_COMMENT;
        }
    }
    private static boolean wroteVal = false;

    private String getTemplateDefComposedName(
        String templateDefName) throws Exception
    {
        Element templateDef;
        String targetObjectName;
        String targetPattern;
        String retVal = null;

        templateDef = MappingXMLTraverser.findTemplateDefWithName(rootXML, templateDefName);
        if(templateDef != null)
        {
            /* step x) get the itemtype of the templateDef and locate a non forward idl valuetype based on that name */
            targetObjectName = MappingXMLTraverser.getXMLElementAttributeValue(templateDef,
                                                                        MappingXMLTraverser.templateDefItemTypeAttributeID);
            if(targetObjectName == null){
                throw new Exception(MappingXMLTraverser.produceElementTrace(templateDef, "Attribute '"+
                    MappingXMLTraverser.templateDefItemTypeAttributeID+"' must be defined for this element."));
            }
            targetPattern = MappingXMLTraverser.getXMLElementAttributeValue(templateDef,
                                                                        MappingXMLTraverser.templateDefPatternAttributeID);
            if(targetPattern == null){
                throw new Exception(MappingXMLTraverser.produceElementTrace(templateDef, "Attribute '"+
                    MappingXMLTraverser.templateDefPatternAttributeID+"' must be defined for this element."));
            }
            retVal = targetObjectName+targetPattern;
        }
        return retVal;
    }

    private String readArrayTokens(
        Vector tokens_out,/* out vector */
        Vector tokens_source) throws Exception
    {
        StringBuffer retVal = new StringBuffer("");
     /*   boolean arrayFound = false;
        for (int count = 0; count < tokens_source.size(); count++)
        {
            String token = (String)tokens_source.get(count);
            int index = token.indexOf(ARRAY_START);
            if(index != -1)
            {
                retVal.append(token.substring(index, token.length()));
                System.out.println("appending: '"+token.substring(index, token.length())+"'");
                remainingTokens.add(token.substring(index, token.length()));
                arrayFound = true;
            } else if(arrayFound)
            {
                retVal.append(token);
                System.out.println("appending: '"+token+"'");
            } else
            {
                remainingTokens.add(token);
            }
        }*/
        return retVal.toString();
    }

    private String readTypeTokens(
        Vector tokens_source)
    {
        StringBuffer buffer = new StringBuffer("");

        for(int count =0; count < tokens_source.size(); count++)
        {
            buffer.append((String)tokens_source.get(count));
        }
        return buffer.toString();
    }

 /*   Vector postConstructedTypeTokens = new Vector();
    Vector preConstructedTypeTokens = new Vector();


    for(int count = 0; count < statememberTokens.size(); count++)
    {
        String token = (String)statememberTokens.get(count);
        if(!constructedTypeDetected){
            int index = token.indexOf(BRACE_OPEN);
            if(index != -1)
            {
                constructedTypeDetected = true;
            }
        } else {
            int index = token.indexOf(BRACE_CLOSE);
            if(index != -1)
            {

            }
        }
    }

*/
    //step 1 scan for '{' so we can detect anonymous structs, unions, enums
    //step 2 scan for '<' so we can detect sequences
    //step 3 scan for '[' so we can detect arrays



    private final void
    transformStatemember(
        Vector statememberTokens) throws Exception
    {
        String name = null;
        String type = "";
        StringBuffer buffer;
        boolean isLocal = false;
        boolean statememberIsRelation = false;
        String mType;

        if(statememberTokens.size() < 2)
        {
            throw new Exception("Invalid state reached! Trying to convert a statemember but missing type or name");
        }
        Vector tempVector = new Vector();
        String arrayString;
        /* read if there are any array, if so coolio. The readArrayTokens op
         * places all tokens not involved in the array defintion stuff in
         * the tempVector out param of the operation!
         */
        arrayString = "";//readArrayTokens(tempVector, statememberTokens);
        //statememberTokens = tempVector;
        /* read the name and remove it from the tokens */
        name = (String)statememberTokens.get(statememberTokens.size()-1);
        statememberTokens.remove(statememberTokens.size()-1);
        /* find out if the statemember is defined as local in the mapping xml */
        isLocal = isStatememberLocal(name);
        statememberIsRelation = isStatememberRelation(name);

        if(isLocal)
        {
            //a local statemember should not be transformed, but we can only
            //determine if it's local after reading all the tokens away, so we
            //have to reform the attribute here, which is rather easy
            if(statememberIsPublic)
            {
                out.write("public ");
            } else {
                out.write("private ");
            }
            for(int count = 0; count < statememberTokens.size(); count++)
            {
                out.write((String)statememberTokens.get(count));
            }
            out.write(";");
        } else if(statememberIsPublic)
        {

            /* now get the type! */
            type = readTypeTokens(statememberTokens);
            if(arrayString.length() > 0)
            {
                out.write("typedef ");
                out.write(type);
                out.write(arrayString);
                out.write(" ");
                out.write(name);
                out.write("_array;");
            }
            out.write("boolean is_");
            out.write(name);
            if(statememberIsRelation)
            {
                out.write("_modified(in DDS::ObjectScope scope);");
            } else
            {
                out.write("_modified();");
            }
            mType = getStatememberMultiRelationTypeName(valuetypeName, name);
            if(mType != null)
            {
                type = mType;
            }
            out.newLine();
            out.write("void set_");
            out.write(name);
            out.write("(in ");
            out.write(type);
            out.write(" value) raises (DDS::PreconditionNotMet);");
            out.newLine();
            out.write(type);
            out.write(" get_");
            out.write(name);
            out.write("();");
            out.newLine();
        }
    }

    private boolean isStatememberLocal(
        String name) throws Exception
    {
        Element classMapping = MappingXMLTraverser.findClassMappingwithName(rootXML, valuetypeName);
        if(classMapping == null)
        {
            throw new Exception("Unable to locate a classMapping element for valuetype '"+valuetypeName+"'. Is the valuetype correctly mapped?");
        }
        Element attributeElement = MappingXMLTraverser.getAttributeMapping(classMapping, name);
        if((attributeElement != null) && (attributeElement.getTagName()).equals(MappingXMLTraverser.localElementID))
        {
            return true;
        }
        return false;
    }

    private boolean isStatememberRelation(
        String name) throws Exception
    {
        Element classMapping = MappingXMLTraverser.findClassMappingwithName(rootXML, valuetypeName);
        if(classMapping == null)
        {
            throw new Exception("Unable to locate a classMapping element for valuetype '"+valuetypeName+"'. Is the valuetype correctly mapped?");
        }
        Element attributeElement = MappingXMLTraverser.getAttributeMapping(classMapping, name);
        if((attributeElement != null) && ((attributeElement.getTagName()).equals(MappingXMLTraverser.monoRelationElementID) || (attributeElement.getTagName()).equals(MappingXMLTraverser.multiRelationElementID)))
        {
            return true;
        }
        return false;
    }

    private boolean isStatememberMultiRelation(
        String vtypeName,
        String name) throws Exception
    {
        Element classMapping = MappingXMLTraverser.findClassMappingwithName(rootXML, vtypeName);
        if(classMapping == null)
        {
            throw new Exception("Unable to locate a classMapping element for valuetype '"+vtypeName+"'. Is the valuetype correctly mapped?");
        }
        Element attributeElement = MappingXMLTraverser.getAttributeMapping(classMapping, name);
        if((attributeElement != null) && ((attributeElement.getTagName()).equals(MappingXMLTraverser.multiRelationElementID)))
        {
            return true;
        }
        return false;
    }

    private String getStatememberMultiRelationTypeName(
        String vtypeName,
        String name) throws Exception
    {
        IdlObject attributeType;
        Element classMapping;
        String templateDefName;
        Element templateDef;
        String targetObjectName;
        String targetPattern;
        String retVal = null;

        if(isStatememberMultiRelation(vtypeName, name))
        {
            classMapping = MappingXMLTraverser.findClassMappingwithName(rootXML, vtypeName);
            if(classMapping == null)
            {
                throw new Exception("Unable to locate a classMapping element for valuetype '"+vtypeName+"'. Is the valuetype correctly mapped?");
            }
            attributeType = getAttributeTypeForClassMappingChildRelation(classMapping, name);

            templateDefName = IDLTraverser.getIDLObjectFullyqualifiedName(attributeType);
            retVal = getTemplateDefComposedName(templateDefName);
        }
        return retVal;
    }

    private IdlObject getAttributeTypeForClassMappingChildRelation(
        Element element,
        String owningRelationName) throws Exception
    {
        Element owningClassMapping;
        String owningName;
        IdlObject owningObject;
        Object owningAttribute;
        IdlStateMember member;
        IdlObject attributeType;

        /* step 1) get the owning objects classmapping and retrieve the name specified there */
        owningClassMapping = (Element)element;
        owningName = MappingXMLTraverser.getNodeValue(owningClassMapping.getAttributes(),
                                                                    MappingXMLTraverser.classMappingNameAttributeID);
        if(owningName == null)
        {
            throw new Exception(MappingXMLTraverser.produceElementTrace(owningClassMapping, "Attribute '"+
                MappingXMLTraverser.classMappingNameAttributeID+"' must be defined for this element."));
        }
        /* step 2) based upon the name of the classMapping we can retrieve IdlObject which the classMapping represents*/
        owningObject = IDLTraverser.getIdlNonForwardValueWithFullyQualifiedName(rootDlrlIdl, owningName);
        if(owningObject == null)
        {
            throw new Exception(MappingXMLTraverser.produceElementTrace(owningClassMapping, "No IDL Valuetype with name '"+
                                                                                owningName+"' found in the DLRL IDL."));
        }
        /* step 3) based upon the Relation of the xml, try and locate the corresponding idl statemember attribute */
        owningAttribute = IDLTraverser.getIdlObjectAttribute(rootDlrlIdl, owningObject, owningRelationName);
        if(owningAttribute == null)
        {
            throw new Exception(MappingXMLTraverser.produceElementTrace(element,
                "IDL Valuetype with name '"+owningName+"' does not contain attribute '"+owningRelationName+
                "' in the DLRL IDL."));
        }
        if(!(owningAttribute instanceof IdlStateMember))
        {
            throw new Exception(MappingXMLTraverser.produceElementTrace(element,
                "IDL Valuetype with name '"+owningName+"' and attribute '"+owningRelationName+
                "' in the DLRL IDL was not an IDL statemember as expected."));
        }
        member = (IdlStateMember)owningAttribute;
        /* step 4) resolve any typedefs and transform any IdlIdent into the final object */
        attributeType = ((IdlObject)member.stateType()).final_object();
        while(attributeType != null && attributeType instanceof IdlTypeDef)
        {
            attributeType = (IdlObject)((IdlTypeDef)attributeType).original();
            if(attributeType instanceof IdlIdent)
            {
                attributeType = (IdlObject)((IdlIdent)attributeType).original();
            }
        }
        if(attributeType instanceof IdlIdent)
        {
            attributeType = (IdlObject)((IdlIdent)attributeType).original();
        }
        if(!(attributeType instanceof IdlValue))
        {
            throw new Exception(MappingXMLTraverser.produceElementTrace(element,
                "The type of attribute '"+owningRelationName+" in IDL Valuetype '"+owningName+"' "+
                "'in the DLRL IDL was not a valuetype as expected."));
        }
        return attributeType;
    }

}
