/*
 *                         OpenSplice DDS
 *
 *   This software and documentation are Copyright 2006 to 2013 PrismTech
 *   Limited and its licensees. All rights reserved. See file:
 *
 *                     $OSPL_HOME/LICENSE 
 *
 *   for full copyright notice and license terms. 
 *
 */
package DCG.BackendDLRL;

import DCG.DCGUtilities.MappingXMLTraversable;
import DCG.DCGUtilities.IDLTraversable;
import DCG.DCGUtilities.MappingXMLTraverser;
import DCG.DCGUtilities.IDLTraverser;
import DCG.Core.MainModel;
import java.util.Vector;
import java.util.HashMap;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import java.util.Iterator;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import org.openorb.compiler.object.IdlArray;
import org.openorb.compiler.object.IdlAttribute;
import org.openorb.compiler.object.IdlConst;
import org.openorb.compiler.object.IdlEnum;
import org.openorb.compiler.object.IdlExcept;
import org.openorb.compiler.object.IdlFactory;
import org.openorb.compiler.object.IdlFixed;
import org.openorb.compiler.object.IdlIdent;
import org.openorb.compiler.object.IdlInterface;
import org.openorb.compiler.object.IdlModule;
import org.openorb.compiler.object.IdlNative;
import org.openorb.compiler.object.IdlObject;
import org.openorb.compiler.object.IdlOp;
import org.openorb.compiler.object.IdlSequence;
import org.openorb.compiler.object.IdlSimple;
import org.openorb.compiler.object.IdlStateMember;
import org.openorb.compiler.object.IdlString;
import org.openorb.compiler.object.IdlStruct;
import org.openorb.compiler.object.IdlStructMember;
import org.openorb.compiler.object.IdlTypeDef;
import org.openorb.compiler.object.IdlUnion;
import org.openorb.compiler.object.IdlUnionMember;
import org.openorb.compiler.object.IdlValue;
import org.openorb.compiler.object.IdlValueBox;
import org.openorb.compiler.object.IdlWString;
import org.openorb.compiler.idl.reflect.idlType;
import org.openorb.compiler.idl.reflect.idlObject;
import org.openorb.compiler.idl.reflect.idlInterface;
import org.openorb.compiler.idl.reflect.idlParameter;

/**
 * This class will generate the DCPS IDL file based upon the XML document
 * generated by the TopicModelGenerator class. The IDL syntax that is outputted
 * shall be conform the IDL grammar from the OMG Corba specification version 2.4.2
 * and conform the DCPS IDL allowed syntax as specified by the DDS specification
 * of OMG.
 */
public class DCPSIDLGenerator implements MappingXMLTraversable, IDLTraversable {

    /**
     * The vector containing the DLRL IDL syntax tree
     */
    private Vector rootDLRLIDL;

    /**
     * Vector containing the scoped names of all IDL types found as declarator name of
     * topic model struct members.
     */
    private Vector scopedIDLTypes = new Vector();

    /**
     * Contains a list of all created DCPSStruct classes, each struct class represents
     * a topic.
     */
    private Vector topics = new Vector();

    /**
     * The traverser used to traverse the topic model document. This traverser is the
     * same as the on used for the Mapping XML file.
     */
    private MappingXMLTraverser xmlTraverser;

    /**
     * The main model used
     */
    private MainModel model;

    private IDLTraverser idlTraverser;

    private StringBuffer tempType;

    private int state = DCPS_PREGENERATION_STATE;
    public static final int DCPS_SEARCH_STATE = 0;
    public static final int DCPS_PREGENERATION_STATE = 1;
    public static final int DCPS_GENERATE_STATE = 2;
    public static final int DCPS_PREGENERATION_ORDER_STATE = 3;
    public static final int DCPS_CHECK_UNION_FOR_STRUCT_STATE = 4;
    private Vector newScopedIDLNames = new Vector();
    private Vector processedScopedIDLNames = new Vector();
    private Vector processedIDLObjectsList = new Vector();
    private Vector sortedScopedIDLNames = new Vector();
    private int indent = 0;
    private Document rootXML;

    /**
     * Specialized constructor
     *
     * @param rootDLRLIDL The vector containing the complete DLRL IDL tree
     * @param topicModel The document containing the entire topic model tree
     * structure. Note that this document should conform to the Mapping XML grammar
     * @param model The main model used
     * @roseuid 40DC43B50175
     */
    public DCPSIDLGenerator(Document mappingXML, Vector rootDLRLIDL, MainModel model) {
        this.model = model;
        this.rootDLRLIDL = rootDLRLIDL;
        this.rootXML = mappingXML;
        xmlTraverser = new MappingXMLTraverser(this);
        idlTraverser = new IDLTraverser(this);
    }

    /**
     * Adds an attribute to one of the existing topics. Must have called
     * canAddAttribute method first.
     *
     * @param topic The name that identifies the topic (DCPSStruct) to which the
     * attribute should be added
     * @param attributeName The declarator name of the attribute being added
     * @param type The type of the attribute being added
     * @roseuid 40DC43BC005C
     */
    public void addAttribute(String topic, String attributeName, String type) {
        DCPSStruct theTopic = getTopic(topic);
        //dont have to check if it is null ro not, as can add attribute has done that
        theTopic.addAttribute(attributeName, type);
    }

    /**
     * Checks to see if an attribute can be added to the topic identified by the topic
     * name. Returns true if the attribute can be added.
     *
     * @param topic The name that identifies the topic (DCPSStruct) to which the
     * attribute should be added
     * @param attributeName The declarator name of the attribute
     * @return boolean
     * @roseuid 40DC43BA0175
     */
    public boolean canAddAttribute(String topic, String attributeName) {
        DCPSStruct theTopic = getTopic(topic);
        if(theTopic!=null && theTopic.canAddAttribute(attributeName)){
            return true;
        }
        return false;
    }

    /**
     * Checks to see if a DCPSStruct with the topic name can be created. Returns true
     * if it can.
     *
     * @param name The name to identify the topic
     * @return boolean
     * @roseuid 40DC43B70156
     */
    public boolean canCreateTopic(String name) {
        Iterator checker = topics.iterator();
        while(checker.hasNext()){
            DCPSStruct aTopic = (DCPSStruct)checker.next();
            if((aTopic.getName()).equals(name)){
                return false;
            }
        }
        return true;
    }

    /**
     * Create a DCPSStruct with the topic name provided.
     *
     * @param name The name to identify the topic
     * @roseuid 40DC43B8033A
     */
    public void createTopic(String name) {
        topics.add(new DCPSStruct(name));
    }

    /**
     * Starts the generation process of the DCPS IDL file
     *
     * @throws Exception
     * @roseuid 408CC56201FE
     */
    public void generateDCPSIDLFile() throws Exception {
        try{
            generateTopics();
            //retrieve the topic mode name
            Element dlrlMappingXMLElement = rootXML.getDocumentElement();
            String dlrlName = MappingXMLTraverser.getNodeValue(dlrlMappingXMLElement.getAttributes(), MappingXMLTraverser.dlrlNameAttributeID);
            if(dlrlName != null){
                writeDCPSIDL(dlrlName);
            } else {
                throw new Exception("The '"+MappingXMLTraverser.dlrlElementID+"' element in the topic model document used does not define a valid value for the '"+MappingXMLTraverser.dlrlNameAttributeID+"' attribute");
            }
        } catch(Exception e){
            String startException = "DCPS IDL Generator\n";
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
    }

    /**
     * Starts the generation of the DCPSStruct objects according to the information
     * found in the topic model syntax tree
     *
     * @throws Exception
     * @roseuid 40DC43C100F8
     */
    private void generateTopics() throws Exception {
        Element rootElement = rootXML.getDocumentElement();
        xmlTraverser.traverseXMLMappingDLRLElement(rootElement);
    }

    /**
     * Searches the DLRL IDL syntax tree for the type of the attribute. Adds the
     * attribute type name to the list of scopedIDLTypes if the attribute is a scoped
     * name.
     *
     * @param parentClassName The name of the IDL object containing the attribute
     * @param attributeName The name of the attribute of which the type is wanted
     * @return java.lang.String
     * @throws Exception
     * @roseuid 40DC4423036C
     */
    private String getAttributeType(String parentClassName, String attributeName) throws Exception {
        tempType = new StringBuffer("");
        int[] types = new int[2];
        types[0] = idlType.VALUE;
        types[1] = idlType.VALUEBOX;
        IdlObject object = IDLTraverser.getIdlObjectWithFullyQualifiedName(rootDLRLIDL, types, parentClassName);
        if(object != null){
            if(object instanceof IdlValue){
                IdlObject idlAttribute = ((IdlValue)object).searchObject(attributeName);
                if(idlAttribute instanceof IdlStateMember){
                    processIDLStateMember((IdlStateMember)idlAttribute);
                } else {
                    if(parentClassName != null){
                        int[] parentTypes = new int[2];
                        parentTypes[0] = idlType.VALUE;
                        parentTypes[1] = idlType.VALUEBOX;
                        IdlObject valueObject = IDLTraverser.getIdlObjectWithFullyQualifiedName(rootDLRLIDL, parentTypes, parentClassName);
                        if(valueObject instanceof IdlValue || valueObject instanceof IdlValueBox){
                            IdlObject anObject = valueObject.searchObject(attributeName.substring(0,attributeName.length()-8));//8 == length of _element
                            if(anObject != null && anObject instanceof IdlStateMember){
                                IdlObject ident = (IdlObject)(((IdlStateMember)anObject).stateType());
                                if(ident instanceof IdlIdent){
                                    String templateDefName = ((IdlIdent)(((IdlStateMember)anObject).stateType())).internalObjectName();
                                    if(templateDefName != null){
                                        Element templateDef = MappingXMLTraverser.getXMLElementWithAttributeValue(rootXML.getDocumentElement(), MappingXMLTraverser.templateDefElementID, MappingXMLTraverser.templateDefNameAttributeID, templateDefName);
                                        if(templateDef!=null){
                                            String itemType = MappingXMLTraverser.getXMLElementAttributeValue(templateDef, MappingXMLTraverser.templateDefItemTypeAttributeID);
                                            if(itemType != null){
                                                IdlObject parentObject = IDLTraverser.getIdlObjectWithFullyQualifiedName(rootDLRLIDL, types, itemType);
                                                if(parentObject !=null){
                                                    return "DLRLOid";
                                                } else {
                                                    return itemType;
                                                }
                                            } else {
                                                throw new Exception("Unable to locate the type for generated object "+attributeName+". Probable cause: missing "+MappingXMLTraverser.templateDefItemTypeAttributeID+" in associated "+MappingXMLTraverser.templateDefElementID+" element");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    //ignore it because it is a generated attribute that isnt found in the DLRL IDL
                }
            }
        } else {
            throw new Exception("The parent class name '"+parentClassName+"' of attribute '"+attributeName+"' is not a valuetype defined in DLRL IDL.");
        }
        return tempType.toString();
    }

    /**
     * Returns the last classMapping element processed by the xml traverser or NULL.
     * This is purely a helper method for the sake of convience.
     * @return IdlObject
     * @throws Exception
     * @roseuid 40DC442502D0
     */
    private IdlObject getLastClassMappingIdlObject() throws Exception {
        int index = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.classMappingElementID);
        if(index != -1){
            Element classMappingElement = xmlTraverser.getProcessedElement(index);
            String className = MappingXMLTraverser.getNodeValue(classMappingElement.getAttributes(), MappingXMLTraverser.classMappingNameAttributeID);
            if(className != null){
                int[] types = new int[2];
                types[0] = idlType.VALUE;
                types[1] = idlType.VALUEBOX;
                return IDLTraverser.getIdlObjectWithFullyQualifiedName(rootDLRLIDL, types, className);
            }
        }
        return null;
    }

    /**
     * Returns a DCPSStruct with the provided name or NULL if no struct is found.
     *
     * @param name The name of the topic wanted
     * @return DCG.BackendDLRL.DCPSIDLGenerator.DCPSStruct
     * @roseuid 40DC43BD02EC
     */
    public DCPSIDLGenerator.DCPSStruct getTopic(String name) {
        Iterator topicIterator = topics.iterator();
        while(topicIterator.hasNext()){
            DCPSStruct aTopic = (DCPSStruct)topicIterator.next();
            if(aTopic.getName().equals(name)){
                return aTopic;
            }
        }
        return null;
    }

    /**
     * Method to write an IDL array object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD4C034F
     */
    public void processIDLArray(IdlArray object) throws Exception {
        if(state == DCPS_GENERATE_STATE){
            int[] dimensions = object.dimensions();
            for(int count =0; count < dimensions.length; count++){
                write("["+dimensions[count]+"]",0);
            }
        }
    }

    /**
     * Method to write an IDL attribute object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD4D00BB
     */
    public void processIDLAttribute(IdlAttribute object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLAttribute(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLAttribute(object);
         }
    }

    /**
     * Method to write an IDL const object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD4D021A
     */
    public void processIDLConst(IdlConst object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLConst(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLConst(object);
         }
    }

    /**
     * Method to write an string context object to the DCPS IDL file output stream.
     *
     * @param context The string object that needs to be processed and traversed
     * further (if possible)
     * @throws Exception
     * @roseuid 40DF224E0274
     */
    public void processIDLContext(String context) throws Exception {

    }

    /**
     * Method to write an IDL declarator object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD4E00DB
     */
    public void processIDLDeclarator(IdlObject object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLDeclarator(object);
        } else if(state == DCPS_GENERATE_STATE){
            write(IDLTraverser.getIDLObjectName(object),0);
            idlTraverser.traverseIDLDeclarator(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
            idlTraverser.traverseIDLDeclarator(object);
        }
    }

    /**
     * Method to write an IDL  enum object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD4E022F
     */
    public void processIDLEnum(IdlEnum object) throws Exception {
        if(state == DCPS_GENERATE_STATE){
            write("enum "+IDLTraverser.getIDLObjectName(object)+"{",0);
            indent++;
            idlTraverser.traverseIDLEnum(object);
            indent--;
            write("}",0);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLEnum(object);
         }
    }

    /**
     * Method to write an string enum memberobject to the DCPS IDL file output stream.
     *
     * @param object The string object that needs to be processed and traversed further (if possible)
     * @param indexOfMember The index of the enum member in the list of enum members
     * @param totalMembers The total size of the enumerator where this element belongs too
     * @throws Exception
     * @roseuid 40DF224F028A
     */
    public void processIDLEnumMember(String object, int indexOfMember, int totalMembers) throws Exception {
        if(state == DCPS_GENERATE_STATE){
            if(indexOfMember == totalMembers-1){
                write(object,0);
            } else {
                write(object+", ",0);
            }
        }
    }

    /**
     * Method to write an IDL exception object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD4F00F0
     */
    public void processIDLExcept(IdlExcept object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLExcept(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLExcept(object);
         }
    }

    /**
     * Method to write an IDL factory(also known as init) object to the DCPS IDL file
     * output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD4F0245
     */
    public void processIDLFactory(IdlFactory object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLFactory(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLFactory(object);
         }
    }

    /**
     * Method to write an IDL fixed object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD4F03A3
     */
    public void processIDLFixed(IdlFixed object) throws Exception {
        throw new Exception("IDL fixed types are not allowed within the DLRL");
    }

    /**
     * Method to write an IDL interface object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD500110
     */
    public void processIDLInterface(IdlInterface object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLInterface(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLInterface(object);
         }
    }

    /**
     * Method to write an IDL inheritance list to the DCPS IDL file output stream.
     *
     * @param inheritanceList The IDL interface inheritance list that needs to be
     * processed and traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD500264
     */
    public void processIDLInterfaceInheritance(idlInterface[] inheritanceList) throws Exception {

    }

    /**
     * Method to write an IDL member object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD5003B9
     */
    public void processIDLMember(IdlStructMember object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLMember(object);
        } else if(state==DCPS_GENERATE_STATE){
            idlTraverser.traverseIDLMember(object);
            write(";",1);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLMember(object);
         }
    }

    /**
     * Method to write an IDL module object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD510125
     */
    public void processIDLModule(IdlObject object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLModule(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLModule(object);
         }
    }

    /**
     * Method to write an IDL native object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD510284
     */
    public void processIDLNative(IdlNative object) throws Exception {

    }

    /**
     * Method to write an IDL operation object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD5103D8
     */
    public void processIDLOperation(IdlOp object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLOperation(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLOperation(object);
         }
    }

    /**
     * Method to write an IDL parameter object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD520145
     */
    public void processIDLParameter(idlParameter object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLParameter(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName((IdlObject)object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName((IdlObject)object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName((IdlObject)object));

             }
             idlTraverser.traverseIDLParameter(object);
         }
    }

    /**
     * Method to write an IDL exception object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD520299
     */
    public void processIDLRaisesException(IdlExcept object) throws Exception {

    }

    /**
     * Method to write an IDL sequence object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD530006
     */
    public void processIDLSequence(IdlSequence object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLSequence(object);
        } else  if(state == DCPS_PREGENERATION_STATE){
            tempType.append("sequence <");
            idlTraverser.traverseIDLSequence(object);
            if(object.getSize() == 0){
                tempType.append(">");
            } else {
                tempType.append(", "+object.getSize()+")>");
            }
        }else if(state== DCPS_GENERATE_STATE){
            write("sequence <",0);
            idlTraverser.traverseIDLSequence(object);
            if(object.getSize() == 0){
                write(">",0);
            } else {
                write(", "+object.getSize()+")>",0);
            }
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLSequence(object);
         } else if(state == DCPS_CHECK_UNION_FOR_STRUCT_STATE){
            idlTraverser.traverseIDLSequence(object);
         }
    }


    /**
     * Method to write an IDL statemember object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD53015A
     */
    public void processIDLStateMember(IdlStateMember object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLStateMember(object);
        } else if(state == DCPS_PREGENERATION_STATE){
            idlTraverser.traverseIDLStateMember(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLStateMember(object);
         }
    }

    /**
     * Method to write an IDL string object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD5302AF
     */
    public void processIDLString(IdlString object) throws Exception {
        if(state == DCPS_PREGENERATION_STATE){
            if(object.max() == 0){
                tempType.append("string");
            } else {
                tempType.append("string <"+object.max()+">");
            }
        } else if(state == DCPS_GENERATE_STATE){
            if(object.max() == 0){
                write("string",0);
            } else {
                write("string <"+object.max()+">",0);
            }
        }
    }

    /**
     * Method to write an IDL struct object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD54001B
     */
    public void processIDLStruct(IdlStruct object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLStruct(object);
        } else if(state == DCPS_GENERATE_STATE){
            processedIDLObjectsList.add(object);
            if(object.isForward()  ){
                write("struct "+IDLTraverser.getIDLObjectName(object),0);
            } else {
                write("struct "+IDLTraverser.getIDLObjectName(object)+"{",1);
                indent++;
                idlTraverser.traverseIDLStruct(object);
                indent--;
                write("}",0);
            }
            processedIDLObjectsList.remove(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 if(!object.isForward()){
                     processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));
                 }

             }
             idlTraverser.traverseIDLStruct(object);
         }
    }

    /**
     * Method to write an IDL type def object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD54017A
     */
    public void processIDLTypeDef(IdlTypeDef object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLTypeDef(object);
        } else if(state == DCPS_GENERATE_STATE){
            write("typedef", 0);
            idlTraverser.traverseIDLTypeDef(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLTypeDef(object);
         }
    }

    /**
     * Method to write an IDL type spec (idl ssimple and idl identity) object to the
     * DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD5402CE
     */
    public void processIDLTypeSpec(IdlObject object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            if(object instanceof IdlIdent){
                IdlObject identObject = ((IdlIdent)object).internalObject();
                if(!newScopedIDLNames.contains(IDLTraverser.getIDLObjectName(identObject))){
                    newScopedIDLNames.add(IDLTraverser.getIDLObjectName(identObject));
                }
            }
        } else if(state == DCPS_GENERATE_STATE || state == DCPS_PREGENERATION_STATE || state == DCPS_CHECK_UNION_FOR_STRUCT_STATE){
            if(object instanceof IdlSimple){
                int type = ((IdlSimple)object).primitive();
                if(type == IdlSimple.ANY){
                    throw new Exception("The 'any' type is not allowed as a DLRL type");
                } else if(type == IdlSimple.BOOLEAN){
                    if(state == DCPS_GENERATE_STATE){
                        write("boolean", 0);
                    } else {
                        tempType.append("boolean");
                    }
                } else if(type == IdlSimple.CHAR){
                    if(state == DCPS_GENERATE_STATE){
                        write("char", 0);
                    } else {
                        tempType.append("char");
                    }
                } else if(type == IdlSimple.DOUBLE){
                    if(state == DCPS_GENERATE_STATE){
                        write("double", 0);
                    } else {
                        tempType.append("double");
                    }
                } else if(type == IdlSimple.FLOAT){
                    if(state == DCPS_GENERATE_STATE){
                        write("float", 0);
                    } else {
                        tempType.append("float");
                    }
                } else if(type == IdlSimple.LONG){
                    if(state == DCPS_GENERATE_STATE){
                        write("long", 0);
                    } else {
                        tempType.append("long");
                    }
                } else if(type == IdlSimple.LONGDOUBLE){
                    if(state == DCPS_GENERATE_STATE){
                        write("long double", 0);
                    } else {
                        tempType.append("long double");
                    }
                } else if(type == IdlSimple.LONGLONG){
                    if(state == DCPS_GENERATE_STATE){
                        write("long long", 0);
                    } else {
                        tempType.append("long long");
                    }
                } else if(type == IdlSimple.OBJECT){
                    throw new Exception("The 'Object' type is not allowed as a DLRL type");
                } else if(type == IdlSimple.OCTET){
                    if(state == DCPS_GENERATE_STATE){
                        write("octet", 0);
                    } else {
                        tempType.append("octet");
                    }
                } else if(type == IdlSimple.SHORT){
                    if(state == DCPS_GENERATE_STATE){
                        write("short", 0);
                    } else {
                        tempType.append("short");
                    }
                } else if(type == IdlSimple.TYPECODE){
                    if(state == DCPS_GENERATE_STATE){
                        write("TypeCode", 0);
                    } else {
                        tempType.append("TypeCode");
                    }
                } else if(type == IdlSimple.ULONG){
                    if(state == DCPS_GENERATE_STATE){
                        write("unsigned long", 0);
                    } else {
                        tempType.append("unsigned long");
                    }
                } else if(type == IdlSimple.ULONGLONG){
                    if(state == DCPS_GENERATE_STATE){
                        write("unsigned long long", 0);
                    } else {
                        tempType.append("unsigned long long");
                    }
                } else if(type == IdlSimple.USHORT){
                    if(state == DCPS_GENERATE_STATE){
                        write("unsigned short", 0);
                    } else {
                        tempType.append("unsigned short");
                    }
                } else if(type == IdlSimple.VALUEBASE){
                    throw new Exception("The 'ValueBase' type is not allowed as a DLRL type");
                } else if(type == IdlSimple.VOID){
                    if(state == DCPS_GENERATE_STATE){
                        write("void", 0);
                    } else {
                        tempType.append("void");
                    }
                } else if(type == IdlSimple.WCHAR){
                    if(state == DCPS_GENERATE_STATE){
                        write("wchar", 0);
                    } else {
                        tempType.append("wchar");
                    }
                }
            } else if(object instanceof IdlIdent){
                IdlObject identObject = ((IdlIdent)object).internalObject();
                if(state == DCPS_GENERATE_STATE){
                    int[] types = new int[2];
                    types[0] = idlType.VALUE;
                    types[1] = idlType.UNION;
                    IdlObject tempObject = IDLTraverser.getIdlObjectWithFullyQualifiedName(rootDLRLIDL, types, IDLTraverser.getIDLObjectName(identObject));
                    if(tempObject instanceof IdlValue && ((IdlValue)tempObject).isForward()){
                        if(processedIDLObjectsList.size() > 0){
                            for(int count = 0; count < processedIDLObjectsList.size(); count++){
                                if(processedIDLObjectsList.get(count) instanceof IdlStruct){
                                    throw new Exception("Forward valuetype ("+IDLTraverser.getIDLObjectName(identObject)+") is not allowed to be defined within a struct ("+IDLTraverser.getIDLObjectName((IdlObject)processedIDLObjectsList.get(count))+"). Even in the deepest levels");
                                }
                            }
                        }
                        write("DLRLOid",0);
                    } else if(tempObject instanceof IdlUnion){
                        if(processedIDLObjectsList.size() > 0){
                            for(int count = 0; count < processedIDLObjectsList.size(); count++){
                                if(processedIDLObjectsList.get(count) instanceof IdlStruct){
                                    state = DCPS_CHECK_UNION_FOR_STRUCT_STATE;
                                    processIDLUnion((IdlUnion)tempObject);
                                    state = DCPS_GENERATE_STATE;
                                }
                            }
                        }
                        write(IDLTraverser.getIDLObjectName(identObject), 0);
                    } else {
                        write(IDLTraverser.getIDLObjectName(identObject), 0);
                    }
                } else if(state == DCPS_CHECK_UNION_FOR_STRUCT_STATE){
                    int[] types = new int[2];
                    types[0] = idlType.VALUE;
                    types[1] = idlType.VALUEBOX;
                    IdlObject tempObject = IDLTraverser.getIdlObjectWithFullyQualifiedName(rootDLRLIDL, types, IDLTraverser.getIDLObjectName(identObject));
                    if(tempObject instanceof IdlValue || tempObject instanceof IdlValueBox){
                        throw new Exception("Forward valuetype ("+IDLTraverser.getIDLObjectName(identObject)+") is not allowed to be defined within a union that is located within a struct");
                    }
                } else {
                    tempType.append(IDLTraverser.getIDLObjectName(identObject));
                    scopedIDLTypes.add(IDLTraverser.getIDLObjectName(identObject));
                }
            }
        }
    }

    /**
     * Method to write an IDL union object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD55003B
     */
    public void processIDLUnion(IdlUnion object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLUnion(object);
        } else if(state == DCPS_GENERATE_STATE){
            processedIDLObjectsList.add(object);
            write("union "+IDLTraverser.getIDLObjectName(object), 0);
            idlTraverser.traverseIDLUnion(object);
            indent--;
            write("}",0);
            processedIDLObjectsList.remove(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLUnion(object);
         } else if(state == DCPS_CHECK_UNION_FOR_STRUCT_STATE){
            idlTraverser.traverseIDLUnion(object);
         }
    }

    public void processIDLUnionDiscriminant(IdlObject object) throws Exception{
        if(object instanceof IdlIdent){
            int[] types = new int[3];
            types[0] = idlType.ENUM;
            types[1] = idlType.TYPEDEF;
            types[2] = idlType.PRIMITIVE ;
            IdlObject tempObject = (IdlObject)((IdlIdent)object).original();
            while(tempObject instanceof IdlTypeDef){
                tempObject = (IdlObject)((IdlTypeDef)tempObject).original();
                if(tempObject instanceof IdlIdent){
                    tempObject = (IdlObject)((IdlIdent)tempObject).original();
                }
            }
            if(!(tempObject instanceof IdlEnum || tempObject instanceof IdlSimple)){
                throw new Exception("Scoped names used for the discriminant of an IDL union may only be (an IDL type def to ) an IDL enumeration or simple type.");
            }

        }
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLUnionDiscriminant(object);
        } else if(state == DCPS_GENERATE_STATE){
            write("switch (",0);
            idlTraverser.traverseIDLUnionDiscriminant(object);
            write("){",1);
            indent++;
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLUnionDiscriminant(object);
         }
    }

    /**
     * Method to write an IDL union member object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD55018F
     */
    public void processIDLUnionMember(IdlUnionMember object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLUnionMember(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLUnionMember(object);
        } else if(state == DCPS_GENERATE_STATE){
            if(!object.isDefault()){
                write("case "+object.value()+":",1);
            } else {
                write("default:",1);
            }
            indent++;
            idlTraverser.traverseIDLUnionMember(object);
            write(";",1);
            indent--;
        } else if(state == DCPS_CHECK_UNION_FOR_STRUCT_STATE){
            idlTraverser.traverseIDLUnionMember(object);
         }
    }
    public void processIDLUnionBranch(java.util.Vector cases) throws Exception{
        System.out.println("TODO: not implemented");
    }

    /**
     * Method to write an IDL valuetype (results in a forward, abstract or def
     * valuetype to be processed) object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD5502EE
     */
    public void processIDLValue(IdlValue object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLValue(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLValue(object);
         }
    }

    /**
     * Method to write an IDL abstract valuetype object to the DCPS IDL file output
     * stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD56005A
     */
    public void processIDLValueAbstractDef(IdlValue object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLValueAbstractDef(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLValueAbstractDef(object);
         }
    }

    /**
     * Method to write an IDL boxed valuetype object to the DCPS IDL file output
     * stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD5601AF
     */
    public void processIDLValueBox(IdlValueBox object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLValueBox(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLValueBox(object);
         }
    }

    /**
     * Method to write an IDL def valuetype object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD560303
     */
    public void processIDLValueDef(IdlValue object) throws Exception {
        if(state == DCPS_SEARCH_STATE){
            idlTraverser.traverseIDLValueDef(object);
        } else if(state == DCPS_PREGENERATION_ORDER_STATE){
             if(processedScopedIDLNames.contains(IDLTraverser.getIDLObjectName(object))){
                 sortedScopedIDLNames.add(IDLTraverser.getIDLObjectName(object));
                 processedScopedIDLNames.remove(IDLTraverser.getIDLObjectName(object));

             }
             idlTraverser.traverseIDLValueDef(object);
         }
    }

    /**
     * Method to write an IDL forward valuetype object to the DCPS IDL file output
     * stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD570070
     */
    public void processIDLValueForwardDef(IdlValue object) throws Exception {

    }

    /**
     * Method to write an IDL value inheritance list to the DCPS IDL file output
     * stream.
     *
     * @param inheritanceList The IDLvaluetype inheritance list that needs to be
     * processed and traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD5701C4
     */
    public void processIDLValueInheritance(IdlValue[] inheritanceList) throws Exception {

    }

    /**
     * Method to write an IDL wide string object to the DCPS IDL file output stream.
     *
     * @param object The IDL object that needs to be processed and traversed further
     * (if possible)
     * @throws Exception
     * @roseuid 40DEBD570319
     */
    public void processIDLWString(IdlWString object) throws Exception {
        if(state == DCPS_PREGENERATION_STATE){
            if(object.max() == 0){
                tempType.append("wstring");
            } else {
                tempType.append("wstring <"+object.max()+">");
            }
        } else if(state == DCPS_GENERATE_STATE){
            if(object.max() == 0){
                write("wstring",0);
            } else {
                write("wstring <"+object.max()+">",0);
            }
        }
    }

    private void searchAllScopedObjects() throws Exception{
        state = DCPS_SEARCH_STATE;
        int[] types = new int[6];
        types[0] = idlType.ENUM;
        types[1] = idlType.STRUCT;
        types[2] = idlType.UNION;
        types[3] = idlType.TYPEDEF;
        types[4] = idlType.VALUE;
        types[5] = idlType.VALUEBOX;
        while(scopedIDLTypes.size() > 0){
            String name = (String)scopedIDLTypes.get(0);
            IdlObject object = IDLTraverser.getIdlObjectWithFullyQualifiedName(rootDLRLIDL, types, name);
            if(object != null && object instanceof IdlEnum){
                processIDLEnum((IdlEnum)object);
                if(!processedScopedIDLNames.contains(name)){
                    processedScopedIDLNames.add(name);
                }
            } else if(object != null && object instanceof IdlStruct){
                processIDLStruct((IdlStruct)object);
                if(!processedScopedIDLNames.contains(name)){
                    processedScopedIDLNames.add(name);
                }
            } else if(object != null && object instanceof IdlUnion){
                processIDLUnion((IdlUnion)object);
                if(!processedScopedIDLNames.contains(name)){
                    processedScopedIDLNames.add(name);
                }
            } else if(object != null && object instanceof IdlTypeDef){
                processIDLTypeDef((IdlTypeDef)object);
                if(!processedScopedIDLNames.contains(name)){
                    processedScopedIDLNames.add(name);
                }
            } else if(object != null && (object instanceof IdlValue || object instanceof IdlValueBox)){
                //ignore
            } else {
                throw new Exception("Unknown scoped name ("+name+") found in object: "+object);
            }
            scopedIDLTypes.remove(name);
        }
        while(newScopedIDLNames.size() > 0){
            String name = (String)newScopedIDLNames.get(0);
            scopedIDLTypes.add(name);
            newScopedIDLNames.remove(name);
        }
        if(scopedIDLTypes.size() > 0){
            searchAllScopedObjects();
        }
    }

    public void generateScopedNameIDLObjects() throws Exception{
        //order the scoped names list first
        state = DCPS_PREGENERATION_ORDER_STATE;
        idlTraverser.traverseIDLTree(rootDLRLIDL);
        state= DCPS_GENERATE_STATE;
        int[] types = new int[4];
        types[0] = idlType.ENUM;
        types[1] = idlType.STRUCT;
        types[2] = idlType.UNION;
        types[3] = idlType.TYPEDEF;
        Vector forwardObjectsProcessed =  new Vector();
        while(sortedScopedIDLNames.size() > 0){
            String name = (String)sortedScopedIDLNames.get(0);
            IdlObject object = IDLTraverser.getIdlObjectWithFullyQualifiedName(rootDLRLIDL, types, name);
            if(object != null && object instanceof IdlEnum){
                processIDLEnum((IdlEnum)object);
                write(";",2);
            } else if(object != null && object instanceof IdlStruct){
                if(forwardObjectsProcessed.contains(name)){
                    object = (IdlObject)((IdlStruct)object).description();
                }
                processIDLStruct((IdlStruct)object);
                if(((IdlStruct)object).isForward()){
                    forwardObjectsProcessed.add(name);
                }
                write(";",2);
            } else if(object != null && object instanceof IdlUnion){
                if(forwardObjectsProcessed.contains(name)){
                    object = (IdlObject)((IdlUnion)object).description();
                }
                processIDLUnion((IdlUnion)object);
                if(((IdlUnion)object).isForward()){
                    forwardObjectsProcessed.add(name);
                }
                write(";",2);
            } else if(object != null && object instanceof IdlTypeDef){
                processIDLTypeDef((IdlTypeDef)object);
                write(";",2);
            } else {
                throw new Exception("Unknown scoped name "+name+" found! "+object);
            }
            sortedScopedIDLNames.remove(name);
        }
    }
    /**
     * Generic method to process place topics, multi place topics, extension topics
     * and main topics.
     *
     * @param topicElement The topic element being processed
     * @param topicID The element id name of the topic element being processed
     * @return java.lang.String
     * @throws Exception
     * @roseuid 40DC43D70399
     */
    private String processTopic(Element topicElement, String topicID) throws Exception {
        String name = null;
        try{
            name = MappingXMLTraverser.getXMLElementAttributeValue(topicElement, MappingXMLTraverser.topicElementNameAttributeID);
            if(name != null && canCreateTopic(name)){
                createTopic(name);
                if(topicID.equals(MappingXMLTraverser.placeTopicElementID)){
                    xmlTraverser.traverseXMLMappingPlaceTopicElement(topicElement);
                } else if(topicID.equals(MappingXMLTraverser.multiPlaceTopicElementID)){
                    xmlTraverser.traverseXMLMappingMultiPlaceTopicElement(topicElement);
                } else if(topicID.equals(MappingXMLTraverser.extensionTopicElementID)){
                    xmlTraverser.traverseXMLMappingExtensionTopicElement(topicElement);
                } else if(topicID.equals(MappingXMLTraverser.mainTopicElementID)){
                    xmlTraverser.traverseXMLMappingMainTopicElement(topicElement);
                } else {
                    throw new Exception("Unknown topic identifier '"+topicID+"'");
                }
            } else {
                throw new Exception("Attribute '"+MappingXMLTraverser.topicElementNameAttributeID+"' must be defined and represent a unique topic name");
            }
        } catch (Exception e){
            String startException = "";
            if(name!=null){
                startException = "\tXML Element: "+topicID+" "+MappingXMLTraverser.topicElementNameAttributeID+"="+name+".\n";
            } else {
                startException = "\tXML Element: "+topicID+".\n";
            }
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
        return name;
    }

    /**
     * Not implemented. (not needed for DCPS IDL generation)
     * @param associationNode
     * @throws Exception
     * @roseuid 40DEBD450132
     */
    public void processXMLMappingAssociationDefElement(Element associationNode) throws Exception {
        //does nothing
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param classMappingNode The Mapping XML element that needs to be processed and
     * traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD450290
     */
    public void processXMLMappingClassMappingElement(Element classMappingNode) throws Exception {
        try{
            String name = MappingXMLTraverser.getNodeValue(classMappingNode.getAttributes(), MappingXMLTraverser.classMappingNameAttributeID);
            if(name !=null){
                int[] types = new int[2];
                types[0] = idlType.VALUE;
                types[1] = idlType.VALUEBOX;
                IdlObject object = IDLTraverser.getIdlNonForwardValueWithFullyQualifiedName(rootDLRLIDL, name);
                if(object == null){
                    throw new Exception("\tNo IDL (non forward) valuetype with name '"+name+"' found in the DLRL IDL");
                } else if( object instanceof IdlValue && ((IdlValue)object).isForward()){
                    throw new Exception("\tIDL Valuetype with name '"+name+"' is a forward valuetype without an implementation. This is not allowed!");
                }
                //check if valuetype is not defined in module DDS
                idlObject definedInObject = object.idlDefinedIn();
                if(definedInObject !=null && definedInObject instanceof IdlModule && (IDLTraverser.getIDLObjectName((IdlObject)definedInObject).equalsIgnoreCase("DDS") )){
                    throw new Exception("\tIllegal valuetype mapping. Valuetype "+name+" is defined in Module "+IDLTraverser.getIDLObjectName((IdlObject)definedInObject)+". This valuetype may not be mapped.");
                }
                if(object instanceof IdlValue){//check inheritance list
                    IdlValue[] inheritanceList = ((IdlValue)object).getInheritance();
                    if(inheritanceList.length > 1){
                        throw new Exception("\tValutype '"+name+"' has multiple inheritence. DLRL only allows single inheritance.");
                    }
                }
                xmlTraverser.traverseXMLMappingClassMappingElement(classMappingNode);
                int index = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.classMappingElementID);
                xmlTraverser.removeProcessedElementsFromListFromIndex(index);
            }
        } catch(Exception e){
            String startException = "\tXML Element: classMapping.\n";
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
    }

    /**
     * Not implemented. (not needed for DCPS IDL generation)
     * @param compoRelationNode
     * @throws Exception
     * @roseuid 40DEBD4503E5
     */
    public void processXMLMappingCompoRelationDefElement(Element compoRelationNode) throws Exception {
        //does nothing
    }

    /**
     * Not implemented. (not needed for DCPS IDL generation)
     * @param enumDefNode
     * @throws Exception
     * @roseuid 40DEBD460151
     */
    public void processXMLMappingEnumDefElement(Element enumDefNode) throws Exception {
        //does nothing
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param extensionTopicNode The Mapping XML element that needs to be processed
     * and traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD4602A6
     */
    public void processXMLMappingExtensionTopicElement(Element extensionTopicNode) throws Exception {
        processTopic(extensionTopicNode, MappingXMLTraverser.extensionTopicElementID);
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param keyDescriptionNode The Mapping XML element that needs to be processed
     * and traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD47001C
     */
    public void processXMLMappingKeyDescriptionElement(Element keyDescriptionNode) throws Exception {
        try{
            xmlTraverser.traverseXMLMappingKeyDescriptionElement(keyDescriptionNode);
            int index = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.keyDescriptionElementID);
            xmlTraverser.removeProcessedElementsFromListFromIndex(index);
        } catch(Exception e){
            String startException = "\tXML Element: "+MappingXMLTraverser.keyDescriptionElementID+".\n";
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
    }

    public void processXMLMappingValidityFieldElement(Element node) throws Exception{
        System.out.println("TODO: not implemented");
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param keyFieldNode The Mapping XML element that needs to be processed and
     * traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD470171
     */
    public void processXMLMappingKeyFieldElement(Element keyFieldNode) throws Exception {
        try{
            xmlTraverser.traverseXMLMappingKeyFieldElement(keyFieldNode);
        } catch(Exception e){
            String startException = "\tXML Element: "+MappingXMLTraverser.keyFieldElementID+".\n";
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param keyFieldNode The Mapping XML element that needs to be processed and
     * traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD4702C5
     */
    public void processXMLMappingKeyFieldTextElement(Node keyFieldNode) throws Exception {
        int index = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.keyDescriptionElementID);
        Element keyDescriptionNode = xmlTraverser.getProcessedElement(index);
        String content = MappingXMLTraverser.getNodeValue(keyDescriptionNode.getAttributes(), MappingXMLTraverser.keyDescriptionContentAttributeID);
        if(content == null || content.equals(MappingXMLTraverser.keyDescriptionContentAttributeNoOidID)){
            throw new Exception(MappingXMLTraverser.keyDescriptionContentAttributeID+" attribute must be defined and have a value of "+MappingXMLTraverser.keyDescriptionContentAttributeFullOidID+" or "+MappingXMLTraverser.keyDescriptionContentAttributeSimpleOidID);
        }
        //size is number of processed elements, index is position of last key description element
        //size - index is number of elements found including key description and all keyfield elements.
        //substract 1 to get number of keyfield elements
        int size = xmlTraverser.getProcessedElementsSize();
        int childElements = size - index -1;
        String type = null;
        if(childElements == 1){
            type = "DLRLOid";
        } else if(childElements == 2){
            type = "string";
        } else {
            throw new Exception("\tIncorrect number of child elements. Require one or two keyfield child elements.");
        }
        String topicName = xmlTraverser.getLastTopicName();//TODO ID: determine if this should be the name or the type name!
        String attributeName = MappingXMLTraverser.getNodeValue(keyFieldNode);
        if(type != null && attributeName != null && canAddAttribute(topicName, attributeName)){
            addAttribute(topicName, attributeName, type);
        } else {
            throw new Exception("\tAttribute '"+type+" "+attributeName+"' already defined in topic '"+topicName+"' or has an invalid value.");
        }
    }

    /**
     * Not implemented. (not needed for DCPS IDL generation)
     * @param localNode
     * @throws Exception
     * @roseuid 40DEBD480032
     */
    public void processXMLMappingLocalElement(Element localNode) throws Exception {
        //local elements are ignored, as they arent mapped to DCPS level
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param mainTopicNode The Mapping XML element that needs to be processed and
     * traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD480186
     */
    public void processXMLMappingMainTopicElement(Element mainTopicNode) throws Exception {
        String name = MappingXMLTraverser.getNodeValue(mainTopicNode.getAttributes(), MappingXMLTraverser.mainTopicNameAttributeID);
        //only process this main topic if it doesnt already exist
        if(canCreateTopic(name)){
            processTopic(mainTopicNode, MappingXMLTraverser.mainTopicElementID);
        }
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param monoAttributeNode The Mapping XML element that needs to be processed and
     * traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD4802DB
     */
    public void processXMLMappingMonoAttributeElement(Element monoAttributeNode) throws Exception {
        try{
            xmlTraverser.traverseXMLMappingMonoAttributeElement(monoAttributeNode);
            int index = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.monoAttributeElementID);
            xmlTraverser.removeProcessedElementsFromListFromIndex(index);
        } catch(Exception e){
            String startException = "\tXML Element: "+MappingXMLTraverser.monoAttributeElementID+".\n";
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param monoRelationNode The Mapping XML element that needs to be processed and
     * traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD490051
     */
    public void processXMLMappingMonoRelationElement(Element monoRelationNode) throws Exception {
        try{
            xmlTraverser.traverseXMLMappingMonoRelationElement(monoRelationNode);
            int index = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.monoRelationElementID);
            xmlTraverser.removeProcessedElementsFromListFromIndex(index);
        } catch(Exception e){
            String startException = "\tXML Element: "+MappingXMLTraverser.monoRelationElementID+".\n";
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param multiAttributeNode The Mapping XML element that needs to be processed
     * and traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD4901A6
     */
    public void processXMLMappingMultiAttributeElement(Element multiAttributeNode) throws Exception {
        try{
            xmlTraverser.traverseXMLMappingMultiAttributeElement(multiAttributeNode);
            int index = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.multiAttributeElementID);
            xmlTraverser.removeProcessedElementsFromListFromIndex(index);
        } catch(Exception e){
            String startException = "\tXML Element: "+MappingXMLTraverser.multiAttributeElementID+".\n";
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param multiPlaceTopicNode The Mapping XML element that needs to be processed
     * and traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD4902FA
     */
    public void processXMLMappingMultiPlaceTopicElement(Element multiPlaceTopicNode) throws Exception {
        processTopic(multiPlaceTopicNode, MappingXMLTraverser.multiPlaceTopicElementID);
        String name = null;
        try{
            boolean error = false;
            name = MappingXMLTraverser.getXMLElementAttributeValue(multiPlaceTopicNode, MappingXMLTraverser.multiPlaceTopicNameAttributeID);
            //attribute name may be null
            String attributeName = MappingXMLTraverser.getXMLElementAttributeValue(multiPlaceTopicNode, MappingXMLTraverser.multiPlaceTopicIndexAttributeID);
            int classMappingIndex = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.classMappingElementID);
            Element parentClassMappingElement = null;

            //String classMappingnameID = null;
            if(classMappingIndex != -1){
                parentClassMappingElement = xmlTraverser.getProcessedElement(classMappingIndex);
                //classMappingnameID = MappingXMLTraverser.multiAttributeNameAttributeID;
            } else {
                error = true;
            }
            int multiAttributeIndex = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.multiAttributeElementID);
            int multirelationIndex = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.multiRelationElementID);
            Element parentElement = null;
            String nameID = null;
            if(multirelationIndex < multiAttributeIndex){
                parentElement = xmlTraverser.getProcessedElement(multiAttributeIndex);
                nameID = MappingXMLTraverser.multiAttributeNameAttributeID;
            } else if(multiAttributeIndex < multirelationIndex){
                parentElement = xmlTraverser.getProcessedElement(multirelationIndex);
                nameID = MappingXMLTraverser.multiRelationNameAttributeID;
            }
            if(parentElement != null){
                String classMappingName = MappingXMLTraverser.getNodeValue(parentClassMappingElement.getAttributes(), MappingXMLTraverser.classMappingNameAttributeID);
                String parentName = MappingXMLTraverser.getNodeValue(parentElement.getAttributes(), nameID);
                int[] parentTypes = new int[2];
                parentTypes[0] = idlType.VALUE;
                parentTypes[1] = idlType.VALUEBOX;
                if(classMappingName!= null && parentName !=null){
                    IdlObject valueObject = IDLTraverser.getIdlObjectWithFullyQualifiedName(rootDLRLIDL, parentTypes, classMappingName);
                    if(valueObject instanceof IdlValue || valueObject instanceof IdlValueBox){
                        IdlObject anObject = valueObject.searchObject(parentName);
                        if(anObject != null && anObject instanceof IdlStateMember){
                            IdlObject ident = (IdlObject)(((IdlStateMember)anObject).stateType());
                            if(ident instanceof IdlIdent){
                                String templateDefName = IDLTraverser.getIDLObjectFullyqualifiedName(((IdlIdent)(((IdlStateMember)anObject).stateType())).internalObject());//internalObjectName();
                                if(templateDefName != null){
                                    Element templateDef = MappingXMLTraverser.getXMLElementWithAttributeValue(rootXML.getDocumentElement(), MappingXMLTraverser.templateDefElementID, MappingXMLTraverser.templateDefNameAttributeID, templateDefName);
                                    if(templateDef!=null){
                                        String pattern = MappingXMLTraverser.getXMLElementAttributeValue(templateDef, MappingXMLTraverser.templateDefPatternAttributeID);
                                        if(pattern.equals(MappingXMLTraverser.templateDefPatternAttributeStrMapValueID) && attributeName != null){
                                            String type = "string";
                                            addAttribute(name, attributeName, type);
                                        } else if(pattern.equals(MappingXMLTraverser.templateDefPatternAttributeIntMapValueID) && attributeName != null){
                                            String type = "long";
                                            addAttribute(name, attributeName, type);
                                        } else if(!pattern.equals(MappingXMLTraverser.templateDefPatternAttributeSetValueID)){
                                            error = true;
                                        }
                                    } else {
                                        error = true;
                                    }
                                } else {
                                    error = true;
                                }
                            } else {
                                error = true;
                            }
                        } else {
                            error = true;
                        }
                    } else {
                        error = true;
                    }
                } else {
                    error = true;
                }
            } else {
                error = true;
            }
            if(error){
                throw new Exception("\tUnable to process the value of the "+MappingXMLTraverser.multiPlaceTopicIndexAttributeID);
            }
        } catch (Exception e){
            String startException = "";
            if(name!=null){
                startException = "\tXML Element: "+MappingXMLTraverser.multiPlaceTopicElementID+" "+MappingXMLTraverser.multiPlaceTopicNameAttributeID+"="+name+".\n";
            } else {
                startException = "\tXML Element: "+MappingXMLTraverser.multiPlaceTopicElementID+".\n";
            }
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param multiRelationNode The Mapping XML element that needs to be processed and
     * traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD4A0067
     */
    public void processXMLMappingMultiRelationElement(Element multiRelationNode) throws Exception {
        try{
            xmlTraverser.traverseXMLMappingMultiRelationElement(multiRelationNode);
            int index = xmlTraverser.getElementLastIndexInProcessedList(MappingXMLTraverser.multiRelationElementID);
            xmlTraverser.removeProcessedElementsFromListFromIndex(index);
        } catch(Exception e){
            String startException = "\tXML Element: "+MappingXMLTraverser.multiRelationElementID+".\n";
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
    }

    /**
     * Not implemented. (not needed for DCPS IDL generation)
     * @param placeTopicNode
     * @throws Exception
     * @roseuid 40DEBD4A01C5
     */
    public void processXMLMappingPlaceTopicElement(Element placeTopicNode) throws Exception {
        //place topics do not exist in generated topic model according to the DDS specification
    }

    /**
     * Not implemented. (not needed for DCPS IDL generation)
     * @param relationNode
     * @throws Exception
     * @roseuid 40DEBD4A031A
     */
    public void processXMLMappingRelationElement(Element relationNode) throws Exception {
        //do nothing
    }

    /**
     * Not implemented. (not needed for DCPS IDL generation)
     * @param templateDefNode
     * @throws Exception
     * @roseuid 40DEBD4B0086
     */
    public void processXMLMappingTemplateDefElement(Element templateDefNode) throws Exception {
        //does nothing
    }

    /**
     * Not implemented. (not needed for DCPS IDL generation)
     * @param valueFieldNode
     * @throws Exception
     * @roseuid 40DEBD4B01DB
     */
    public void processXMLMappingValueElement(Element valueFieldNode) throws Exception {
        //do nothing
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param valueFieldNode The Mapping XML element that needs to be processed and
     * traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD4B032F
     */
    public void processXMLMappingValueFieldElement(Element valueFieldNode) throws Exception {
        try{
            xmlTraverser.traverseXMLMappingValueFieldElement(valueFieldNode);
        } catch(Exception e){
            String startException = "\tXML Element: "+MappingXMLTraverser.valueFieldElementID+".\n";
            Exception tmp = new Exception(startException+e.getMessage(), e.getCause());
            tmp.setStackTrace(e.getStackTrace());
            throw tmp;
        }
    }

    /**
     * Mapping XML element being traversed and all relevant data for the DCPS IDL
     * generation is extracted.
     *
     * @param valueFieldNode The Mapping XML element that needs to be processed and
     * traversed further (if possible)
     * @throws Exception
     * @roseuid 40DEBD4C009C
     */
    public void processXMLMappingValueFieldTextElement(Node valueFieldNode) throws Exception {
        String topicName = xmlTraverser.getLastTopicName();//TODO ID: determine if this should be the name or the type name!
        IdlObject parentObject = getLastClassMappingIdlObject();
        String parentClassName = IDLTraverser.getIDLObjectFullyqualifiedName(parentObject);
        String attributeName = MappingXMLTraverser.getNodeValue(valueFieldNode);
        IdlObject declarator = parentObject.searchObject(attributeName);
        String array ="";
        if(declarator != null && declarator.type() instanceof IdlArray){
            int[] dimensions = ((IdlArray)declarator.type()).dimensions();

            for(int count =0; count < dimensions.length; count++){
                array+="["+dimensions[count]+"]";
            }
        }
        if(!canAddAttribute(topicName, attributeName+array)){
            throw new Exception("\tAttribute '"+attributeName+"' already defined in topic '"+topicName+"'.");
        }
        if(attributeName == null){
            throw new Exception("\tA valuefield defined in topic '"+topicName+"' has an invalid value (I.E. no value).");
        }
        String type = getAttributeType(parentClassName, attributeName);
        addAttribute(topicName, attributeName+array, type);

    }

    /**
     * Not implemented. (not needed for DCPS IDL generation)
     * @param valueNode
     * @throws Exception
     * @roseuid 40DEBD4C01F0
     */
    public void processXMLMappingValueTextElement(Node valueNode) throws Exception {
        //do nothing
    }





    BufferedWriter out = null;

    /**
     * This method is responsible for writing the DCPS IDL file to the file output
     * stream. All scoped IDL names are processed and generated before DCPS structs
     * are generated.
     *
     * @param fileNameWithoutExtension The file name without extension (extension will
     * be .idl by default)
     * @throws Exception
     * @roseuid 40DC43BF0146
     */

    private void writeIncludes() throws Exception{
        write("#include \"dds_dlrl\".idl", 2);
    }



    private void writeDCPSIDL(String fileNameWithoutExtension) throws Exception {
        File outputResult = model.getOutputDirectoryPath();
        outputResult.mkdirs();
        File outputFile = new File(outputResult.getAbsolutePath()+File.separator+fileNameWithoutExtension+".idl");
        out = new BufferedWriter(new FileWriter(outputFile));
        write("module "+fileNameWithoutExtension+" {",2);
        indent++;
        //write default struct defining the DLRLOid
        write("struct DLRLOid{",1);
        indent++;
        write("unsigned long creator_id;",1);
        write("unsigned long local_id;",1);
        indent--;
        write("};",2);
        searchAllScopedObjects();
        generateScopedNameIDLObjects();
        Iterator topicIterator = topics.iterator();
        while(topicIterator.hasNext()){
            DCPSStruct aTopic = (DCPSStruct)topicIterator.next();
            write("struct "+aTopic.getName()+"{",1);
            indent++;
            Iterator attributeIterator = aTopic.getAttributes().keySet().iterator();
            while(attributeIterator.hasNext()){
                String attributeName = (String)attributeIterator.next();
                String attributeType = (String)(aTopic.getAttributes()).get(attributeName);
                write(attributeType+" "+attributeName+";",1);
            }
            indent--;
            write("};",1);
            writeNoIndent("#pragma keylist "+aTopic.getName(), 2);
        }
        indent--;
        write("};",0);
        out.close();
    }
    boolean lastPrintHadNewLine = false;

    private void writeNoIndent(String text, int newLines) throws Exception{
        write(text, newLines, 0);
    }

    private void write(String text, int newLines, int indents) throws Exception{
        for(int count = 0; count < indents && lastPrintHadNewLine; count++){
            out.write('\t');
        }
        out.write(text+" ");
        for (int count = 0; count < newLines; count++){
            out.newLine();
            lastPrintHadNewLine = true;
        }
        if(newLines == 0){
            lastPrintHadNewLine = false;
        }
    }

    private void write(String text, int newLines) throws Exception{
        write(text, newLines, indent);
    }

    /**
     * An inner class used to hold the information of a DCPS struct which needs to be
     * generated.
     */
    public class DCPSStruct {

        /**
         * A map of all attributes. The attribute name is the key and the type is the
         * value. Both are String objects.
         */
        private HashMap attributes = new HashMap();

        /**
         * The name of the DCPS struct
         */
        private String name;

        /**
         * Specialized constructor
         *
         * @param name The name that identifies the topic (DCPSStruct)
         * @roseuid 40DC45A60076
         */
        public DCPSStruct(String name) {
            this.name = name;
        }

        /**
         * Adds an attribute to the attributes list
         *
         * @param name The declarator name of the attribute being added
         * @param type The type of the attribute being added
         * @roseuid 40DC45AF01BE
         */
        public void addAttribute(String name, String type) {
            attributes.put(name, type);
        }

        /**
         * Method to check if an attribute can be added to the attributes list. Returns
         * true if it is allowed.
         *
         * @param name The declarator name of the attribute being added
         * @return boolean
         * @roseuid 40DC45B2022B
         */
        public boolean canAddAttribute(String name) {
            return !attributes.containsKey(name);
        }

        /**
         * Returns the attributes list of this DCPSStruct
         * @return java.util.HashMap
         * @roseuid 40DC45D90384
         */
        public HashMap getAttributes() {
            return attributes;
        }

        /**
         * Returns the topic name of this DCPSStruct
         * @return java.lang.String
         * @roseuid 40DC45AB0028
         */
        public String getName() {
            return name;
        }

        /**
         * Removes the attribute with the provided name from the attributes list
         *
         * @param name The declarator name of the attribute being removed
         * @roseuid 40DC45B500A5
         */
        private void removeAttribute(String name) {
            attributes.remove(name);
        }
    }
}
