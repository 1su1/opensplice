/*
 *                         OpenSplice DDS
 *
 *   This software and documentation are Copyright 2006 to 2013 PrismTech
 *   Limited and its licensees. All rights reserved. See file:
 *
 *                     $OSPL_HOME/LICENSE 
 *
 *   for full copyright notice and license terms. 
 *
 */
package DCG.FrontendIDL;

import java.util.Enumeration;
import java.util.Vector;

import org.openorb.compiler.CompilerProperties;
import org.openorb.compiler.object.IdlObject;
import org.openorb.compiler.parser.IdlParser;

import DCG.Core.ParserHolderable;

/**
 * The IDLParserHolder class is the holder class for the external IDL parser
 * defined in the External IDL parser layer. This class is needed because the
 * parserHolderable class needs to be implemented to allow the IDL parser to be
 * compatible with the Core layer without making changes to the existing IDL
 * parser. The ParserHolderable class must be implemented to allow multiple
 * frontends to be used by the Core without giving the core knowledge of the exact
 * implementation of a parser.
 */
public class IDLParserHolder implements ParserHolderable, org.openorb.compiler.parser.ErrorHandler {

	private static boolean compliantMessageShown = false;
    private boolean verbose = false;
    private IDLErrorHandler handler = null;
    /**
     * Default constructor
     * @roseuid 407415280308
     */
	public IDLParserHolder(
        boolean verbose,
        IDLErrorHandler handler)
    {
        this.handler = handler;
        this.verbose = verbose;
		if(!IDLParserHolder.compliantMessageShown && verbose)
        {
			System.out.println("- Notification: IDL Parser is IDL version 2.4.2 compliant.");
			IDLParserHolder.compliantMessageShown = true;
		}
	}
    /**
     * Implemented parser interface method. Accesses the external parser  package and
     * instructs it to start parsing.
     *
     * @param targetFile The target file to be parsed
     * @param targetValidationFile The optional validation file for the target file to
     * be parsed. May be NULL
     * @return java.lang.Object
     * @throws Exception
     * @roseuid 407294E801B8
     */
	public Object parseFile(java.io.File targetFile, java.io.File targetValidationFile, Vector includePaths) throws Exception{

        CompilerProperties cp = new CompilerProperties();

        // set the package name
		cp.setM_packageName(System.getProperty("DCG.packageName", ""));

		// set the include list
		Vector list = cp.getM_includeList();
        String includeList = System.getProperty("DCG.includeList");
		if (null != includeList) {
            String[] folders = includeList.split(System.getProperty("path.separator"));
            for (int i = 0; i < folders.length; i++)
                list.add(folders[i]);
        }
        for(int count =0; count < includePaths.size(); count++){
            java.io.File aFile = (java.io.File)includePaths.get(count);
            list.add(aFile.getAbsolutePath());
        }

		IdlParser parser = new IdlParser(cp);
        //reset the output stream to system.out (again) as the variable that we are setting is defined as a static
        //variable which means the error output of a parser is determined at initilisation time and this prevents
        //tools that redirect the system.out to another output stream to take notice of various error messages
        //generated by the idl parser
        parser.setErrorOutput(java.lang.System.out);
        if(handler != null)
        {
            parser.setHandler(this);
        }
		IdlObject compilationGraph = null;
        if(verbose){
            System.out.println("- Notification: Using the following parser for IDL parsing: "+ parser.getClass().getName());
        }
		try{
			compilationGraph = parser.compile_idl( targetFile.getAbsolutePath() );
            Vector usedReaders = parser.usedReaders;
            for(int count = 0; count < usedReaders.size(); count++){
                java.io.Reader aReader = (java.io.Reader)usedReaders.get(count);
                try{
                    aReader.close();
                } catch (Exception e){
                    if(verbose){
                        System.out.println("- Warning: Failed to close input stream. Detailed info: ");
                        e.printStackTrace();
                    }
                }
            }

			if ( parser.getTotalErrors() != 0 || compilationGraph == null ){
				if(parser.getTotalErrors()==1){
					throw new Exception( "There is " + parser.getTotalErrors() + " compilation error while parsing file '"+targetFile.getAbsolutePath()+"'!");
				} else {
					throw new Exception( "There are " + parser.getTotalErrors() + " compilation errors while parsing file '"+targetFile.getAbsolutePath()+"'!");
				}
			}
		} catch(Exception e){
			if(e.getClass().getName().equals("java.lang.Exception")){
				throw e;
			} else {
				StringBuffer msg = new StringBuffer("IDL Parser:\n");
				if(parser != null && parser.getTotalErrors() != 0){
                    msg.append( "There is " + parser.getTotalErrors() + " compilation error while parsing file '"+targetFile.getAbsolutePath()+"'!");
				} else {
					msg.append( "There are " + parser.getTotalErrors() + " compilation errors while parsing file '"+targetFile.getAbsolutePath()+"'!");
				}
				if(e.getMessage() != null && parser != null && parser.getTotalErrors() != 0){
					msg.append("\nAdditional error details: " +e.getMessage());
				} else if(e.getMessage() != null){
					msg.append(e.getMessage());
				} else if(e.getMessage() == null && !(parser != null && parser.getTotalErrors() != 0)){
					msg.append("\nFailed to correctly parse IDL file "+targetFile.getName()+".");
				}
                Exception tmp = new Exception(msg.toString(), e.getCause());
                tmp.setStackTrace(e.getStackTrace());
                throw tmp;

			}
		}
		if(compilationGraph != null){
			return (Object)convertEnumerationToVector( compilationGraph.content() );
		} else {
			throw new Exception("IDL parsing failed, no compilation graph was built. File: "+targetFile.getName());
		}

	}

	private Vector convertEnumerationToVector(Enumeration myEnum){
		Vector tempVector = new Vector();
		while(myEnum.hasMoreElements()){
			tempVector.add(myEnum.nextElement());
		}
		return tempVector;
	}

    public void error(
        String fileName,
        int line,
        String message)
    {
        handler.error(fileName, line, message);
    }

    public void warning(
        String fileName,
        int line,
        String message)
    {
        handler.warning(fileName, line, message);
    }

    /* Invoked when the maximum number of errors is exceeded, after which
     * compilation of the IDL file is stopped.
     */
    public void maxErrorsExceeded(
        String fileName,
        int maxErrors)
    {
        handler.maxErrorsExceeded(fileName, maxErrors);
    }
}
