/*
 *                         OpenSplice DDS
 *
 *   This software and documentation are Copyright 2006 to 2013 PrismTech
 *   Limited and its licensees. All rights reserved. See file:
 *
 *                     $OSPL_HOME/LICENSE 
 *
 *   for full copyright notice and license terms. 
 *
 */
package DCG.DCGUtilities;

import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Vector;
import org.openorb.compiler.idl.reflect.idlInterface;
import org.openorb.compiler.idl.reflect.idlParameter;
import org.openorb.compiler.idl.reflect.idlException;
import org.openorb.compiler.idl.reflect.idlType;
import org.openorb.compiler.object.IdlArray;
import org.openorb.compiler.object.IdlAttribute;
import org.openorb.compiler.object.IdlConst;
import org.openorb.compiler.object.IdlEnum;
import org.openorb.compiler.object.IdlExcept;
import org.openorb.compiler.object.IdlFactory;
import org.openorb.compiler.object.IdlFixed;
import org.openorb.compiler.object.IdlIdent;
import org.openorb.compiler.object.IdlInterface;
import org.openorb.compiler.object.IdlModule;
import org.openorb.compiler.object.IdlNative;
import org.openorb.compiler.object.IdlObject;
import org.openorb.compiler.object.IdlOp;
import org.openorb.compiler.object.IdlParam;
import org.openorb.compiler.object.IdlSequence;
import org.openorb.compiler.object.IdlSimple;
import org.openorb.compiler.object.IdlStateMember;
import org.openorb.compiler.object.IdlString;
import org.openorb.compiler.object.IdlStruct;
import org.openorb.compiler.object.IdlStructMember;
import org.openorb.compiler.object.IdlTypeDef;
import org.openorb.compiler.object.IdlUnion;
import org.openorb.compiler.object.IdlUnionMember;
import org.openorb.compiler.object.IdlValue;
import org.openorb.compiler.object.IdlValueBox;
import org.openorb.compiler.object.IdlWString;
import org.openorb.compiler.parser.SymboleJava;
import org.openorb.compiler.parser.SymboleDef;
import org.openorb.compiler.idl.reflect.idlPrimitive;

/**
 * This class provides generic functionality to traverse the IDL syntax tree as
 * generated by the OpenOrb 1.3.1 IDL parser. This class also provides several
 * useful IDL helper functions. Any class that wants to traverse the entire or
 * partial IDL syntax tree should use the class. This class allows for each object
 * in the syntax tree that has child objects (including inheritance lists etc) to
 * be traversed correctly, without having to worry how the IDL tree structure
 * works. The traversing of the IDL tree can start at any node in the tree by
 * calling the specific traverse method. The general starting point for tree
 * traversal is the traverseIDLTree(..) method.Classes that use this class must
 * implement the IDLTraversable interface and call the specialized constructor in
 * this class.
 */
public class IDLTraverser {

    public static boolean verbose = false;

    /**
     * The target class implementing the IDLTraversable interface. During tree
     * traversal the processIDL...(..) methods in this object will be called.
     */
    private IDLTraversable target;

    public static final int BOOLEAN = 0;

    public static final int DOUBLE = 1;

    public static final int FLOAT = 2;

    public static final int LONG = 3;

    public static final int LONGLONG = 4;

    public static final int OCTET = 5;

    public static final int SHORT = 6;

    public static final int ULONG = 7;

    public static final int ULONGLONG = 8;

    public static final int USHORT = 9;

    /**
     * Specialized constructor
     *
     * @param target The target class implementing the IDLTraversable interface.
     * @roseuid 40DA8C7C0304
     */
    public IDLTraverser(IDLTraversable target){
        this.target = target;
    }

    /**
     * Return a vector containing only the specified child types of the provided IDL
     * Object.
     *
     * @param object The parent object from which to start the filtering process
     * @param types The int array containing the idlType values wanted
     * @return java.util.Vector
     * @roseuid 40DA96EB02DF
     */
    public static Vector filterIdlObject(IdlObject object, int[] types){
        Vector allFilteredObjects =  new Vector();
        for(int count = 0; count < types.length; count++){
            Enumeration filteredObjects = object.filter(types[count]);
            while(filteredObjects.hasMoreElements()){
                IdlObject anObject = (IdlObject)filteredObjects.nextElement();
                if(!allFilteredObjects.contains(anObject)){
                    allFilteredObjects.add(anObject);
                }

            }
        }
        return allFilteredObjects;
    }

    public static final IdlObject resolveTypedefAndIdlIdent(IdlObject object){
        while(object != null && object instanceof IdlTypeDef){
            object = (IdlObject)((IdlTypeDef)object).original();//resolve typedef
            if(object != null && object instanceof IdlIdent){
                object = (IdlObject)((IdlIdent)object).original();
            }
        }
        if(object != null && object instanceof IdlIdent){
            object = (IdlObject)((IdlIdent)object).original();
        }
        return object;
    }

    /**
     * Returns the attribute if the IDL object provided contains an attribute with the
     * attribute name provided.
     *
     * @param parentObject The IDL object that possibly contains the attribute
     * @param attributeName The name of the attribute that is searched for
     * @return boolean
     * @roseuid 40DA8D6C033B
     */
    public static Object getIdlObjectAttribute(Vector rootIDL, IdlObject parentObject, String attributeName) throws Exception{
        if(parentObject instanceof IdlEnum){
            String[] childElements = ((IdlEnum)parentObject).members();
            for(int enumCount = 0; enumCount < childElements.length; enumCount++){
                String enumString = (String)childElements[enumCount];
                if(enumString.equals(attributeName)){
                    return (Object)enumString;
                }
            }
        } else {
            java.util.Enumeration childElements = null;
             if(parentObject instanceof IdlStruct){
                childElements = ((IdlStruct)parentObject).members();
            } else {
                childElements = parentObject.content();
            }
            while(childElements.hasMoreElements()){
                IdlObject childElement = (IdlObject)childElements.nextElement();
                int seperatorIndex = attributeName.indexOf(".");
                if(seperatorIndex == -1){
                    if(IDLTraverser.getIDLObjectName(childElement) != null && IDLTraverser.getIDLObjectName(childElement).equals(attributeName)){
                        return (Object)childElement;
                    }
                } else if(IDLTraverser.getIDLObjectName(childElement) != null &&
                                                IDLTraverser.getIDLObjectName(childElement).equals(attributeName.substring(0, seperatorIndex))){
                    if(seperatorIndex < attributeName.length()-1){
                        if(childElement instanceof IdlStructMember){
                            if(((IdlStructMember)childElement).internal() != null){
                                if(((IdlStructMember)childElement).internal() instanceof IdlIdent){
                                    IdlObject resolvedObject = getIdlObjectWithFullyQualifiedName(rootIDL, getAllIdlTypes(),
                                                            getIDLObjectFullyqualifiedName((IdlObject)((IdlIdent)((IdlStructMember)childElement).internal()).original()));
                                    return (Object)getIdlObjectAttribute(rootIDL, resolvedObject , attributeName.substring(seperatorIndex+1, attributeName.length()));
                                }
                            }
                        }
                    } else {
                        return null;
                    }
                }
            }
        }
        return null;
    }

    public static int[] getAllIdlTypes(){
        int[] types = new int[25];
        types[0] = idlType.ARRAY;
        types[1] = idlType.ATTRIBUTE;
        types[2] = idlType.CONST;
        types[3] = idlType.ENUM;
        types[4] = idlType.EXCEPTION;
        types[5] = idlType.FACTORY;
        types[6] = idlType.FIXED;
        types[7] = idlType.IDENTIFIER;
        types[8] = idlType.INTERFACE;
        types[9] = idlType.MODULE;
        types[10] = idlType.NATIVE;
        types[11] = idlType.OPERATION;
        types[12] = idlType.PARAM;
        types[13] = idlType.PRIMITIVE;
        types[14] = idlType.SEQUENCE;
        types[15] = idlType.STATE;
        types[16] = idlType.STRING;
        types[17] = idlType.STRUCT;
        types[18] = idlType.STRUCT_MEMBER;
        types[19] = idlType.TYPEDEF;
        types[20] = idlType.UNION;
        types[21] = idlType.UNION_MEMBER;
        types[22] = idlType.VALUE;
        types[23] = idlType.VALUEBOX;
        types[24] = idlType.WSTRING;
        return types;
    }

    public static boolean areAttributeTypesEqual(Object attribute1, Object attribute2) throws Exception{
        boolean areEqual = false;
        if(attribute1 instanceof String && attribute2 instanceof String){
            areEqual = true;
        } else if(attribute1 instanceof IdlObject && attribute2 instanceof IdlObject){
            int type1 = getAttributeType(((IdlObject)attribute1).final_object().type());
            int type2 = getAttributeType(((IdlObject)attribute2).final_object().type());
            areEqual = type1 == type2;
            if(areEqual){
                //TODO if types are union, struct or enum then validate them!!!!
                //sequences and arrays also need to be validated better
                if(type1 == org.openorb.compiler.parser.Token.t_union){

                    if(verbose){
                        System.out.println("- Warning: Detected an union as attribute type for attributes '"+
                            getIDLObjectFullyqualifiedName((IdlObject)attribute1)+"' and '"+getIDLObjectFullyqualifiedName((IdlObject)attribute2)+
                            "'. Unions are not (yet) validated for internal consistency with eachother. They should be completely consistant, in this release even in name.");
                    }
                } else if(type1 == org.openorb.compiler.parser.Token.t_struct){
                    if(verbose){
                        System.out.println("- Warning: Detected a struct as attribute type for attributes '"+
                            getIDLObjectFullyqualifiedName((IdlObject)attribute1)+"' and '"+getIDLObjectFullyqualifiedName((IdlObject)attribute2)+
                            "'. Structs are not (yet) validated for internal consistency with eachother. They should be completely consistant, in this release even in name.");
                    }
                } else if(type1 == org.openorb.compiler.parser.Token.t_enum){
                    if(verbose){
                        System.out.println("- Warning: Detected an enum as attribute type for attributes '"+
                            getIDLObjectFullyqualifiedName((IdlObject)attribute1)+"' and '"+getIDLObjectFullyqualifiedName((IdlObject)attribute2)+
                            "'. Enums are not (yet) validated for internal consistency with eachother. They should be completely consistant, in this release even in name.");
                    }
                }
            }
        } else {
            return false;
            //TODO improve error reporting... throw new Exception("Fatal error: Unsupported attribute types. Aborting...");
        }
        return areEqual;
    }

    public static boolean isAttributeTypeLong(IdlObject attribute)throws Exception{
        return getAttributeType(attribute) == org.openorb.compiler.parser.Token.t_long;
    }

    public static boolean isAttributeTypeString(IdlObject attribute)throws Exception{
        return getAttributeType(attribute) == org.openorb.compiler.parser.Token.t_string;
    }
    public static int getAttributeType(IdlObject attribute) throws Exception{
        int type;

        if(attribute instanceof org.openorb.compiler.object.IdlSequence){
            type = getAttributeType((IdlObject)((org.openorb.compiler.object.IdlSequence)attribute).internal());
        } else if(attribute instanceof org.openorb.compiler.object.IdlUnionMember){
            type = getAttributeType((IdlObject)((org.openorb.compiler.object.IdlUnionMember)attribute).internal());
        } else if(attribute instanceof org.openorb.compiler.object.IdlArray){
            type = getAttributeType((IdlObject)((org.openorb.compiler.object.IdlArray)attribute).internal());
        } else if(attribute instanceof org.openorb.compiler.object.IdlStructMember){
            type = getAttributeType((IdlObject)((org.openorb.compiler.object.IdlStructMember)attribute).internal());
        } else if(attribute instanceof org.openorb.compiler.object.IdlSimple){
            type = ((org.openorb.compiler.object.IdlSimple)attribute).internal();
        } else if(attribute instanceof org.openorb.compiler.object.IdlIdent){
            type = getAttributeType(((org.openorb.compiler.object.IdlIdent)attribute).internalObject());
        } else if(attribute instanceof org.openorb.compiler.object.IdlString){
            type = org.openorb.compiler.parser.Token.t_string;
        } else if(attribute instanceof org.openorb.compiler.object.IdlWString){
            type = org.openorb.compiler.parser.Token.t_wstring;
        } else if(attribute instanceof org.openorb.compiler.object.IdlUnion){
            type = org.openorb.compiler.parser.Token.t_union;
        } else if(attribute instanceof org.openorb.compiler.object.IdlStruct){
            type = org.openorb.compiler.parser.Token.t_struct;
        } else if(attribute instanceof org.openorb.compiler.object.IdlEnum){
            type = org.openorb.compiler.parser.Token.t_enum;
        } else if(attribute instanceof org.openorb.compiler.object.IdlTypeDef){
            type = getAttributeType((IdlObject)((org.openorb.compiler.object.IdlTypeDef)attribute).original());
        } else {
            throw new Exception("Unknown type! Type was: "+attribute.getClass().getName()+". Aborting...");
        }
        return type;
    }
    public static final String STRING_TXT = "string";
    public static final String WSTRING_TXT = "wstring";
    public static final String UNION_TXT = "union";
    public static final String STRUCT_TXT = "struct";
    public static final String ENUM_TXT = "enum";
    public static final String VOID_TXT = "void";
    public static final String BOOLEAN_TXT = "boolean";
    public static final String FLOAT_TXT = "float";
    public static final String DOUBLE_TXT = "double";
    public static final String LONG_DOUBLE_TXT = "long double";
    public static final String SHORT_TXT = "short";
    public static final String UNSIGNED_SHORT_TXT = "unsigned short";
    public static final String LONG_TXT = "long";
    public static final String UNSIGNED_LONG_TXT = "unsigned long";
    public static final String LONG_LONG_TXT = "long long";
    public static final String UNSIGNED_LONG_LONG_TXT = "unsigned long long";
    public static final String CHAR_TXT = "char";
    public static final String WCHAR_TXT = "wchar";
    public static final String OCTET_TXT = "octet";
    public static final String OBJECT_TXT = "Object";
    public static final String ANY_TXT = "any";
    public static final String TYPECODE_TXT = "TypeCode";
    public static final String VALUEBASE_TXT = "ValueBase";
    public static final String UNKNOWN_TYPE_TXT = "unknown";

    public static String attributeTypeToString(
        int type)
    {
        String retVal;

        switch (type)
        {
        case org.openorb.compiler.parser.Token.t_string:
            retVal = STRING_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_wstring:
            retVal = WSTRING_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_union:
            retVal = UNION_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_struct:
            retVal = STRUCT_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_enum:
            retVal = ENUM_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_void:
            retVal = VOID_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_boolean:
            retVal = BOOLEAN_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_float:
            retVal = FLOAT_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_double:
            retVal = DOUBLE_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_longdouble:
            retVal = LONG_DOUBLE_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_short:
            retVal = SHORT_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_ushort:
            retVal = UNSIGNED_SHORT_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_long:
            retVal = LONG_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_ulong:
            retVal = UNSIGNED_LONG_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_longlong:
            retVal = LONG_LONG_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_ulonglong:
            retVal = UNSIGNED_LONG_LONG_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_char:
            retVal = CHAR_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_wchar:
            retVal = WCHAR_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_octet:
            retVal = OCTET_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_object:
            retVal = OBJECT_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_any:
            retVal = ANY_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_typecode:
            retVal = TYPECODE_TXT;
            break;
        case org.openorb.compiler.parser.Token.t_ValueBase:
            retVal = VALUEBASE_TXT;
            break;
        default:
            retVal = UNKNOWN_TYPE_TXT;
            break;
        }
        return retVal;
    }

    public static boolean valuetypeInheritsFromObjectRoot(IdlValue object){
        IdlValue[] values = object.getInheritance();
        for(int count = 0; count < values.length; count++){
            IdlValue aValue = values[count];
            if(getIDLObjectFullyqualifiedName(aValue).equals("DDS::ObjectRoot")){
                return true;
            } else {
                return valuetypeInheritsFromObjectRoot(aValue);
            }
        }
        return false;
    }

    public static boolean isDDSObjectRoot(IdlValue object){
        String nameFQ = getIDLObjectFullyqualifiedName(object);
        if(nameFQ != null && nameFQ.equals("DDS::ObjectRoot")){
            return true;
        }
        return false;
    }

    public static Vector getAllNonForwardDLRLValuetypes(Vector rootIDL){
        Vector dlrlValuetypes = new Vector();
        int count;
        IdlObject object;
        java.util.Enumeration interestedTypes;
        IdlValue element;

        for (count = 0; count < rootIDL.size(); count++){
            object = (IdlObject)rootIDL.get(count);
            if(object instanceof IdlValue && !((IdlValue) object).forward() &&
                                                        IDLTraverser.valuetypeInheritsFromObjectRoot((IdlValue)object)){
                dlrlValuetypes.add(object);
            }
            interestedTypes = object.filter(idlType.VALUE);
            while(interestedTypes.hasMoreElements()){
                element = (IdlValue)interestedTypes.nextElement();
                if(!element.forward() && IDLTraverser.valuetypeInheritsFromObjectRoot((IdlValue)element)){
                    dlrlValuetypes.add(element);
                }
            }
        }
        return dlrlValuetypes;
    }

    /**
     * This method returns the name of the IDL object. This method takes into
     * consideration if the name is a java keyword, in which case special rules apply.
     * It also takes into consideration if an underscore was removed by the
     * prepocessor, if so it reappends the underscore before returning the name.
     *
     * @param object The IDL Object to retrieve the name from
     * @return String
     * @roseuid 40DA8D5300D9
     */
     public static String getIDLObjectName(IdlObject object){
         String name = object.name();
         if(name != null){
            return name.startsWith("_") ? name.substring(1) : name;
         }
         return null;
     }

    public static String getIDLObjectFullyqualifiedName(IdlObject object){
        //start with the object name
        StringBuffer buffer = new StringBuffer(getIDLObjectName(object));
        object = (IdlObject)object.idlDefinedIn();
        while(object!=null){
            if(object.idlType() == idlType.MODULE){
                buffer.insert(0, "::");
                buffer.insert(0, getIDLObjectName(object));
            }
            object = (IdlObject)object.idlDefinedIn();
        }
        return buffer.toString();
    }

    public static String stripModulePrefixFromIDLName(String idlName){
        int index = idlName.lastIndexOf("::");
        if(index == -1){
            return idlName;
        } else if((index+2) < idlName.length()){
            return idlName.substring(index+2, idlName.length());
        }
        return "";
    }

    public static String getIdlPrimitiveStringName(idlPrimitive simple) throws Exception{
        switch(simple.primitive()){
            case idlPrimitive.ANY:
                return "any";
            case idlPrimitive.BOOLEAN:
                return "boolean";
            case idlPrimitive.CHAR:
                return "char";
            case idlPrimitive.DOUBLE:
                return "double";
            case idlPrimitive.FLOAT:
                return "float";
            case idlPrimitive.LONG:
                return "long";
            case idlPrimitive.LONGDOUBLE:
                return "long double";
            case idlPrimitive.LONGLONG:
                return "long long";
            case idlPrimitive.OBJECT:
                return "Object";
            case idlPrimitive.OCTET:
                return "octet";
            case idlPrimitive.SHORT:
                return "short";
            case idlPrimitive.TYPECODE:
                return "TypeCode";
            case idlPrimitive.ULONG:
                return "unsigned long";
            case idlPrimitive.ULONGLONG:
                return "unsigned long long";
            case idlPrimitive.USHORT:
                return "unsigned short";
            case idlPrimitive.VALUEBASE:
                return "ValueBase";
            case idlPrimitive.VOID:
                return "void";
	        case idlPrimitive.WCHAR:
                return "wchar";
            default:
                throw new Exception("Illegal state: Unknown primitive type detected.");
        }
    }

    /**
     * This method will search the vector provided for IDL Objects with the provided
     * name (will not search child elements). Will return the object once found. Will
     * return null if no object was found.
     *
     * @param rootIDL The IDL syntax tree to search through
     * @param name The name of the IDL object wanted
     * @param types The list of IDL objects to search through
     * @return IdlObject
     * @roseuid 40DA8D670166
     */
    public static IdlObject getIdlObjectWithName(Vector rootIDL, int[] types, String name){
        if(rootIDL != null){
            for (int count = 0; count < rootIDL.size(); count++){
                IdlObject object = (IdlObject)rootIDL.get(count);
                if(IDLTraverser.getIDLObjectName(object) != null && IDLTraverser.getIDLObjectName(object).equals(name)){
                    return object;
                }
            }
        }
        return null;
    }


    public static Vector splitFullyQualifiedName(String fqName) {
        StringTokenizer tokenizer = new StringTokenizer(fqName, "::");
        int tokenCount = tokenizer.countTokens();
        Vector tokens = new Vector();
        for(int count = 0; count < tokenCount; count++){
            String token = tokenizer.nextToken();
            tokens.add(token);
        }
        return tokens;
    }


    public static Vector resolveModule(Vector rootIDL, Vector moduleNames, boolean throwException) throws Exception{
        int[] moduleTypes = new int[1];
        moduleTypes[0] = idlType.MODULE;
        Vector subRootIDL = rootIDL;
        for(int count = 0; count < (moduleNames.size()); count++){
            String token = (String) moduleNames.get(count);
            IdlObject aModule = IDLTraverser.getIdlObjectWithName(rootIDL, moduleTypes, token);
            if(aModule !=null){
                subRootIDL = new Vector();
                java.util.Enumeration myEnum = aModule.content() ;
                while(myEnum.hasMoreElements()){
                    subRootIDL.add(myEnum.nextElement());
                }
                rootIDL = subRootIDL;
            } else if(throwException){
                throw new Exception("Unable to locate an IDL module with name '"+token+
                                                        "'! Module is not defined or the scope specified is invalid.");
            } else {
                return null;
            }
        }
        return subRootIDL;
    }


    public static IdlObject getIdlObjectWithFullyQualifiedName(Vector rootIDL, int[] types, String fullyQualifiedName) throws Exception{
        if(rootIDL != null){
            Vector tokens = splitFullyQualifiedName(fullyQualifiedName);
            if(tokens.size() > 0){
                String name = (String) tokens.remove(tokens.size() - 1);
                Vector subRootIDL = resolveModule(rootIDL, tokens, true);
                IdlObject object = IDLTraverser.getIdlObjectWithName(subRootIDL, types, name);
                if(object == null){
                    throw new Exception("Unable to resolve IDL object with fully qualified name '"+fullyQualifiedName+
                            "'. No such object could be located.");
                }
                String tmp = getIDLObjectFullyqualifiedName(object);
                if(!tmp.equals(fullyQualifiedName)){
                    throw new Exception("Unable to resolve IDL object with fully qualified name '"+fullyQualifiedName+
                            "'. Did locate another similar object in a different module '"+tmp+"'");
                }
                return object;
            }
        }
        return null;
    }

    public static boolean doesIdlObjectWithFullyQualifiedNameExist(Vector rootIDL, int[] types, String fullyQualifiedName) throws Exception{
        if(rootIDL != null){
            Vector tokens = splitFullyQualifiedName(fullyQualifiedName);
            if(tokens.size() > 0){
                String name = (String) tokens.remove(tokens.size() - 1);
                Vector subRootIDL = resolveModule(rootIDL, tokens, false);
                if(subRootIDL != null){
                    IdlObject object = IDLTraverser.getIdlObjectWithName(subRootIDL, types, name);
                    if(object != null){
                        String tmp = getIDLObjectFullyqualifiedName(object);
                        if(tmp.equals(fullyQualifiedName)){
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    /**
     * This method will search the vector provided for IDL Non Forward Valuetypes with
     * the provided name (will not search child elements). Will return the object once
     * found. Will return null if no object was found.
     *
     * @param rootIDL The IDL syntax tree to search through
     * @param name The name of the IDL object wanted
     * @return IdlValue
     */
    public static IdlValue getIdlNonForwardValueWithName(Vector rootIDL, String name) throws Exception{
        if(rootIDL != null){
            for (int count = 0; count < rootIDL.size(); count++){
                IdlObject object = (IdlObject)rootIDL.get(count);
                if(IDLTraverser.getIDLObjectName(object) != null && IDLTraverser.getIDLObjectName(object).equals(name)
                        && object instanceof IdlValue && !((IdlValue) object).forward()){
                    return (IdlValue) object;
                }
                java.util.Enumeration interestedTypes = object.filter(idlType.VALUE);
                while(interestedTypes.hasMoreElements()){
                    IdlValue element = (IdlValue)interestedTypes.nextElement();
                    if(element != null && IDLTraverser.getIDLObjectName(element)!= null && IDLTraverser.getIDLObjectName(element).equals(name) && !element.forward()){
                        return element;
                    }
                }
            }
        }
        return null;
    }


    public static IdlValue getIdlNonForwardValueWithFullyQualifiedName(Vector rootIDL, String fullyQualifiedName) throws Exception{
        if(rootIDL != null){
            Vector tokens = splitFullyQualifiedName(fullyQualifiedName);
            if(tokens.size() > 0){
                String name = (String) tokens.remove(tokens.size() - 1);
                Vector subRootIDL = resolveModule(rootIDL, tokens, true);
                return IDLTraverser.getIdlNonForwardValueWithName(subRootIDL, name);
            }
        }
        return null;
    }

    /**
     * Checks if the provided name isnt a Java reserved word. Return true if the name
     * is a reserved Java word, false if not.
     *
     * @param name The name to check to see if it is a reserved word
     * @return boolean
     * @roseuid 40DA8D65002E
     */
    private static boolean isJavaReservedWord(String name){
        int i = 0;
        SymboleDef symbol;
        for (int count = 0; count < SymboleJava.liste_mots_reserves.size(); count++){
            symbol = (SymboleDef) SymboleJava.liste_mots_reserves.elementAt(count);
            if (symbol.symbole_name.equals(name)){
                return true;
            }
        }
        return false;
    }

    /**
     * This method implements the functionality to traverse the IDL attribute object
     * and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CC803B3
     */
    public void traverseIDLAttribute(IdlAttribute object) throws Exception{
        IdlObject childObject = object.type();
        if(childObject instanceof IdlSimple || childObject instanceof IdlIdent){
            target.processIDLTypeSpec(childObject);
        } else if(childObject instanceof IdlString){
            target.processIDLString((IdlString)childObject);
        } else if(childObject instanceof IdlWString){
            target.processIDLWString((IdlWString)childObject);
        } else {
            throw new Exception("..::IDLAttribute::..Unexpected child object type : "+childObject.getClass().getName());
        }
    }

    /**
     * This method implements the functionality to traverse the IDL const object and
     * will call the respective process...(..) method in the associated IDLTraversable
     * class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CCA027A
     */
    public void traverseIDLConst(IdlConst object) throws Exception{
        IdlObject childObject = (IdlObject)object.constantType();
        if(childObject instanceof IdlSimple || childObject instanceof IdlIdent){
            target.processIDLTypeSpec(childObject);
        } else if(childObject instanceof IdlSequence){
            target.processIDLSequence((IdlSequence)childObject);
        } else if(childObject instanceof IdlString){
            target.processIDLString((IdlString)childObject);
        } else if(childObject instanceof IdlWString){
            target.processIDLWString((IdlWString)childObject);
        } else if(childObject instanceof IdlFixed){
            target.processIDLFixed((IdlFixed)childObject);
        } else {
            throw new Exception("..::IDLConst::..Unexpected child object type : "+childObject.getClass().getName());
        }
    }

    /**
     * This method implements the functionality to traverse the IDL declarator object
     * and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CCC01FE
     */
    public void traverseIDLDeclarator(IdlObject object) throws Exception{
        if(object.type() instanceof IdlArray){
            target.processIDLArray((IdlArray)object.type());
        }
    }

    /**
     * This method implements the functionality to traverse the IDL enum object and
     * will call the respective process...(..) method in the associated IDLTraversable
     * class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CCE022C
     */
    public void traverseIDLEnum(IdlEnum object) throws Exception{
        String[] members = object.members();
        for(int count = 0; count < members.length; count++){
            String member = (String)members[count];
            target.processIDLEnumMember(member, count, members.length);
        }
    }

    /**
     * This method implements the functionality to traverse the IDL exception object
     * and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CD000F4
     */
    public void traverseIDLExcept(IdlExcept object) throws Exception{
        Enumeration members = object.members();
        while(members.hasMoreElements()){
            IdlStructMember childObject = (IdlStructMember)members.nextElement();
            if(childObject != null){
                target.processIDLMember(childObject);
            }
        }
    }

    /**
     * This method implements the functionality to traverse the IDL factory object
     * (also known as init) and will call the respective process...(..) method in the
     * associated IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CD103A4
     */
    public void traverseIDLFactory(IdlFactory object) throws Exception{
        idlParameter[] params = object.parameters();
        for(int count = 0; count < params.length; count++){
            idlParameter param = params[count];
            target.processIDLParameter(param);
        }
    }

    /**
     * This method implements the functionality to traverse the IDL interface object
     * and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CD302AA
     */
    public void traverseIDLInterface(IdlInterface object) throws Exception{
        //process inheritance list
        target.processIDLInterfaceInheritance(object.inheritance());
        //process child elements
        Enumeration content = object.content();
        while(content.hasMoreElements()){
            IdlObject childObject = (IdlObject)content.nextElement();
            if(childObject          instanceof IdlTypeDef){
                target.processIDLTypeDef((IdlTypeDef)childObject);
            } else if(childObject   instanceof IdlStruct){
                target.processIDLStruct((IdlStruct)childObject);
            } else if(childObject   instanceof IdlUnion){
                target.processIDLUnion((IdlUnion)childObject);
            } else if(childObject   instanceof IdlEnum){
                target.processIDLEnum((IdlEnum)childObject);
            } else if(childObject   instanceof IdlNative){
                target.processIDLNative((IdlNative)childObject);
            } else if(childObject   instanceof IdlConst){
                target.processIDLConst((IdlConst)childObject);
            } else if(childObject   instanceof IdlExcept){
                target.processIDLExcept((IdlExcept)childObject);
            } else if(childObject   instanceof IdlAttribute){
                target.processIDLAttribute((IdlAttribute)childObject);
            } else if(childObject   instanceof IdlOp){
                target.processIDLOperation((IdlOp)childObject);
            } else {
                throw new Exception("..::IdlInterface::..Unexpected child object type : "+childObject.getClass().getName());
            }
        }
    }

    /**
     * This method implements the functionality to traverse the IDL member object and
     * will call the respective process...(..) method in the associated IDLTraversable
     * class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CD5021D
     */
    public void traverseIDLMember(IdlStructMember object) throws Exception{
        IdlObject childObject = (IdlObject)object.type();
        if(childObject instanceof IdlArray){
            childObject = (IdlObject)((IdlArray)object.type()).internal();
        }
        if(childObject instanceof IdlSimple || childObject instanceof IdlIdent){
            target.processIDLTypeSpec(childObject);
        } else if(childObject instanceof IdlStruct){
            target.processIDLStruct((IdlStruct)childObject);
        } else if(childObject instanceof IdlUnion){
            target.processIDLUnion((IdlUnion)childObject);
        } else if(childObject instanceof IdlEnum){
            target.processIDLEnum((IdlEnum)childObject);
        }else if(childObject instanceof IdlSequence){
            target.processIDLSequence((IdlSequence)childObject);
        } else if(childObject instanceof IdlString){
            target.processIDLString((IdlString)childObject);
        } else if(childObject instanceof IdlWString){
            target.processIDLWString((IdlWString)childObject);
        } else if(childObject instanceof IdlFixed){
            target.processIDLFixed((IdlFixed)childObject);
        } else {
            throw new Exception("..::IDLMember::..Unexpected child object type : "+childObject.getClass().getName());
        }
        target.processIDLDeclarator((IdlObject)object);
    }

    /**
     * This method implements the functionality to traverse the IDL module object and
     * will call the respective process...(..) method in the associated IDLTraversable
     * class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CD702B9
     */
    public void traverseIDLModule(IdlObject object) throws Exception{
        Enumeration content = object.content();
        while(content.hasMoreElements()){
            IdlObject childObject = (IdlObject)content.nextElement();
            if(childObject          instanceof IdlTypeDef){
                target.processIDLTypeDef((IdlTypeDef)childObject);
            } else if(childObject   instanceof IdlStruct){
                target.processIDLStruct((IdlStruct)childObject);
            } else if(childObject   instanceof IdlUnion){
                target.processIDLUnion((IdlUnion)childObject);
            } else if(childObject   instanceof IdlEnum){
                target.processIDLEnum((IdlEnum)childObject);
            } else if(childObject   instanceof IdlNative){
                target.processIDLNative((IdlNative)childObject);
            } else if(childObject   instanceof IdlConst){
                target.processIDLConst((IdlConst)childObject);
            } else if(childObject   instanceof IdlExcept){
                target.processIDLExcept((IdlExcept)childObject);
            } else if(childObject   instanceof IdlInterface){
                target.processIDLInterface((IdlInterface)childObject);
            } else if(childObject   instanceof IdlModule){
                target.processIDLModule((IdlModule)childObject);
            } else if(childObject   instanceof IdlValue){
                target.processIDLValue((IdlValue)childObject);
            } else if(childObject   instanceof IdlValueBox){
                target.processIDLValueBox((IdlValueBox)childObject);
            } else if(childObject   instanceof IdlSimple){      //redundant for error checking as the parser sometimes returns an idl simple as child element of a module for (so far unknown reasons)
                if(getIDLObjectName(object) != null && !(getIDLObjectName(object).equals("CORBA"))){
                    throw new Exception("..::IdlModule::..Unexpected child object type : "+object.getClass().getName());
                }
            } else {
                throw new Exception("..::IdlModule::..Unexpected child object type : "+object.getClass().getName());
            }
        }
    }

    /**
     * This method implements the functionality to traverse the IDL operation object
     * and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CD9027B
     */
    public void traverseIDLOperation(IdlOp object) throws Exception{
        //process the type spec for this idl operation
        IdlObject childObject = (IdlObject)object.returnType();
        if(childObject instanceof IdlSimple || childObject instanceof IdlIdent){    //TYPEREF
            target.processIDLTypeSpec(childObject);
        } else if(childObject instanceof IdlString){                                //STRING
            target.processIDLString((IdlString)childObject);
        } else if(childObject instanceof IdlWString){                               //WSTRING
            target.processIDLWString((IdlWString)childObject);
        } else {
            throw new Exception("..::IDLOperation::..Unexpected child object type : "+childObject.getClass().getName());
        }

        //process the params defined for this operation
        idlParameter[] params = object.parameters();
        for(int count = 0; count < params.length; count++){
            idlParameter param = params[count];
            if(param instanceof IdlParam){
                target.processIDLParameter((IdlParam)param);
            } else {
                //error
            }
        }
        //process the exceptions raised by this operation
        idlException[] exceptions = object.exceptions();
        for(int count = 0;count < exceptions.length; count++){
            idlException exception = exceptions[count];
            if(exception instanceof IdlExcept){
                target.processIDLRaisesException((IdlExcept)exception);
            } else {
                //error
            }
        }
        //process the contexts of this operation
        String[] contexts   =   object.contexts();
        for(int count = 0;count < contexts.length; count++){
            String context = contexts[count];
            target.processIDLContext(context);
        }
    }

    /**
     * This method implements the functionality to traverse the IDL parameter object
     * and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CDB02BA
     */
    public void traverseIDLParameter(idlParameter object) throws Exception{
        IdlObject childObject = (IdlObject)object.paramType();
        if(childObject instanceof IdlSimple || childObject instanceof IdlIdent){    //TYPEREF
            target.processIDLTypeSpec(childObject);
        } else if(childObject instanceof IdlString){                                //STRING
            target.processIDLString((IdlString)childObject);
        } else if(childObject instanceof IdlWString){                               //WSTRING
            target.processIDLWString((IdlWString)childObject);
        } else {
            throw new Exception("..::IDLParameter::..Unexpected child object type : "+childObject.getClass().getName());
        }
    }

    /**
     * This method implements the functionality to traverse the IDL sequence object
     * and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CE30327
     */
    public void traverseIDLSequence(IdlSequence object) throws Exception{
        IdlObject childObject = (IdlObject)(IdlObject)object.internal();
        if(childObject instanceof IdlSimple || childObject instanceof IdlIdent){
            target.processIDLTypeSpec(childObject);
        } else if(childObject instanceof IdlSequence){
            target.processIDLSequence((IdlSequence)childObject);
        } else if(childObject instanceof IdlString){
            target.processIDLString((IdlString)childObject);
        } else if(childObject instanceof IdlWString){
            target.processIDLWString((IdlWString)childObject);
        } else if(childObject instanceof IdlFixed){
            target.processIDLFixed((IdlFixed)childObject);
        } else {
            throw new Exception("..::IDLSequence::..Unexpected child object type : "+childObject.getClass().getName());
        }
    }

    /**
     * This method implements the functionality to traverse the IDL statemember object
     * and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CDD02AA
     */
    public void traverseIDLStateMember(IdlStateMember object) throws Exception{
        IdlObject childObject = object.type();
        if(object.type() instanceof IdlArray){
            childObject = (IdlObject)((IdlArray)object.type()).internal();
        }
        if(childObject instanceof IdlSimple || childObject instanceof IdlIdent){
            target.processIDLTypeSpec(childObject);
        } else if(childObject instanceof IdlStruct){
            target.processIDLStruct((IdlStruct)childObject);
        } else if(childObject instanceof IdlUnion){
            target.processIDLUnion((IdlUnion)childObject);
        } else if(childObject instanceof IdlEnum){
            target.processIDLEnum((IdlEnum)childObject);
        }else if(childObject instanceof IdlSequence){
            target.processIDLSequence((IdlSequence)childObject);
        } else if(childObject instanceof IdlString){
            target.processIDLString((IdlString)childObject);
        } else if(childObject instanceof IdlWString){
            target.processIDLWString((IdlWString)childObject);
        } else if(childObject instanceof IdlFixed){
            target.processIDLFixed((IdlFixed)childObject);
        } else {
            throw new Exception("..::IDLStateMember::..Unexpected child object type : "+childObject.getClass().getName());
        }
        target.processIDLDeclarator((IdlObject)object);
    }

    /**
     * This method implements the functionality to traverse the IDL struct object and
     * will call the respective process...(..) method in the associated IDLTraversable
     * class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CDF01FE
     */
    public void traverseIDLStruct(IdlStruct object) throws Exception{
        Enumeration members = object.members();
        while(members.hasMoreElements()){
            IdlStructMember member = (IdlStructMember)members.nextElement();
            target.processIDLMember(member);
        }
    }

    /**
     * This method implements the functionality to traverse the IDL tree and will call
     * the respective process...(..) method in the associated IDLTraversable class for
     * each child object found.
     *
     * @param rootIDL The vector containing the complete IDL tree. This contents of
     * this vector is an exact copy of the content of the Enumeration object returned
     * by the OpenOrb IDL parser version 1.3.1
     * @throws Exception
     * @roseuid 40DA8CC60374
     */
    public void traverseIDLTree(Vector rootIDL) throws Exception{
        for(int count = 0; count < rootIDL.size(); count++){
            IdlObject object = (IdlObject)rootIDL.get(count);
            if(object instanceof IdlTypeDef){
                target.processIDLTypeDef((IdlTypeDef)object);
            } else if(object instanceof IdlStruct){
                target.processIDLStruct((IdlStruct)object);
            } else if(object instanceof IdlUnion){
                target.processIDLUnion((IdlUnion)object);
            } else if(object instanceof IdlEnum){
                target.processIDLEnum((IdlEnum)object);
            } else if(object instanceof IdlNative){
                target.processIDLNative((IdlNative)object);
            } else if(object instanceof IdlConst){
                target.processIDLConst((IdlConst)object);
            } else if(object instanceof IdlExcept){
                target.processIDLExcept((IdlExcept)object);
            } else if(object instanceof IdlInterface){
                target.processIDLInterface((IdlInterface)object);
            } else if(object instanceof IdlModule){
                target.processIDLModule((IdlModule)object);
            } else if(object instanceof IdlValue){
                target.processIDLValue((IdlValue)object);
            } else if(object instanceof IdlValueBox){
                target.processIDLValueBox((IdlValueBox)object);
            } else {
                throw new Exception("..::IdlDefinition::..Unexpected child object type : "+object.getClass().getName());
            }
        }
    }

    /**
     * This method implements the functionality to traverse the IDL typedef object and
     * will call the respective process...(..) method in the associated IDLTraversable
     * class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CE101DF
     */
    public void traverseIDLTypeDef(IdlTypeDef object) throws Exception{
        IdlObject childObject = object.type();
        if(object.type() instanceof IdlArray){
            childObject = (IdlObject)((IdlArray)object.type()).internal();
        }
        if(childObject instanceof IdlSimple || childObject instanceof IdlIdent){    //TYPEREF
            target.processIDLTypeSpec(childObject);
        } else if(childObject instanceof IdlStruct){                                //STRUCT
            target.processIDLStruct((IdlStruct)childObject);
        } else if(childObject instanceof IdlUnion){                                 //UNION
            target.processIDLUnion((IdlUnion)childObject);
        } else if(childObject instanceof IdlEnum){                                  //ENUM
            target.processIDLEnum((IdlEnum)childObject);
        }else if(childObject instanceof IdlSequence){                               //SEQUENCE
            target.processIDLSequence((IdlSequence)childObject);
        } else if(childObject instanceof IdlString){                                //STRING
            target.processIDLString((IdlString)childObject);
        } else if(childObject instanceof IdlWString){                               //WSTRING
            target.processIDLWString((IdlWString)childObject);
        } else if(childObject instanceof IdlFixed){                                 //FIXED
            target.processIDLFixed((IdlFixed)childObject);
        } else {
            throw new Exception("..::IDLTypeDef::..Unexpected child object type : "+childObject.getClass().getName());
        }
        target.processIDLDeclarator((IdlObject)object);
    }

    /**
     * This method implements the functionality to traverse the IDL union object and
     * will call the respective process...(..) method in the associated IDLTraversable
     * class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CE50308
     */
  /*  public void traverseIDLUnion(IdlUnion object) throws Exception{
        IdlObject discriminant = (IdlObject)object.discriminant();
        target.processIDLUnionDiscriminant(discriminant);
        Enumeration content = object.content();
        while(content.hasMoreElements()){
            IdlUnionMember childObject = (IdlUnionMember)content.nextElement();
            target.processIDLUnionMember(childObject);
        }
    }*/

    public void traverseIDLUnion(IdlUnion object) throws Exception{
        Vector branches = new Vector();
        IdlObject discriminant = (IdlObject)object.discriminant();
        target.processIDLUnionDiscriminant(discriminant);
        Enumeration content = object.content();
        while(content.hasMoreElements()){
            IdlUnionMember childObject = (IdlUnionMember)content.nextElement();
            String objectName = null;
            if(((IdlObject)childObject) instanceof IdlTypeDef){
                objectName = IDLTraverser.getIDLObjectFullyqualifiedName(childObject);
            } else {
                objectName = IDLTraverser.getIDLObjectName(childObject);
            }
            /* transform into branches */
            UnionBranch branch = null;
            for(int count = 0; count < branches.size() && branch == null; count++){
                UnionBranch aBranch = (UnionBranch)branches.get(count);
                if(aBranch.name.equals(objectName)){
                    branch = aBranch;
                }
            }
            if(branch == null){
                branch = new UnionBranch();
                branch.name = objectName;
                branches.add(branch);
            }
            branch.cases.add(childObject);
        }
        for(int count = 0; count < branches.size(); count++){
            target.processIDLUnionBranch(((UnionBranch)branches.get(count)).cases);
        }
    }



public class UnionBranch{
    public String name;
    public Vector cases = new Vector();
}

    public void traverseIDLUnionDiscriminant(IdlObject object) throws Exception{
        if(object instanceof IdlEnum){
            target.processIDLEnum((IdlEnum)object);
        } else if(object instanceof IdlIdent || object instanceof IdlSimple){
            target.processIDLTypeSpec(object);
        } else if(object instanceof IdlTypeDef){
            target.processIDLDeclarator((IdlObject)object);
        } else {
            throw new Exception("..::IdlUnion::..Unexpected child object type : "+object.getClass().getName());
        }
    }


    /**
     * This method implements the functionality to traverse the IDL union object and
     * will call the respective process...(..) method in the associated IDLTraversable
     * class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CE7029B
     */
    public void traverseIDLUnionMember(IdlUnionMember object) throws Exception{
        IdlObject childObject = object.type();
        if(childObject instanceof IdlArray){
            childObject = (IdlObject)((IdlArray)object.type()).internal();
        }
        if(childObject instanceof IdlUnionMember){
            //ignore for now TODO decide what to do, probably nothing
        } else if(childObject instanceof IdlSimple || childObject instanceof IdlIdent){
            target.processIDLTypeSpec(childObject);
        } else if(childObject instanceof IdlStruct){
            target.processIDLStruct((IdlStruct)childObject);
        } else if(childObject instanceof IdlUnion){
            target.processIDLUnion((IdlUnion)childObject);
        } else if(childObject instanceof IdlEnum){
            target.processIDLEnum((IdlEnum)childObject);
        }else if(childObject instanceof IdlSequence){
            target.processIDLSequence((IdlSequence)childObject);
        } else if(childObject instanceof IdlString){
            target.processIDLString((IdlString)childObject);
        } else if(childObject instanceof IdlWString){
            target.processIDLWString((IdlWString)childObject);
        } else if(childObject instanceof IdlFixed){
            target.processIDLFixed((IdlFixed)childObject);
        } else {
            throw new Exception("..::IDLUnionMember::..Unexpected child object type : "+childObject.getClass().getName());
        }
        target.processIDLDeclarator(object);
    }

    /**
     * This method implements the functionality to traverse the IDL valuetype object
     * and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8CE9021E
     */
    public void traverseIDLValue(IdlValue object) throws Exception{
        if(object.isForward()){
            target.processIDLValueForwardDef(object);
        } else if(object.abstract_value()){
            target.processIDLValueAbstractDef(object);
        } else {
            target.processIDLValueDef(object);
        }
    }

    /**
     * This method implements the functionality to traverse the IDL abstract valuetype
     * object and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8D4A03E6
     */
    public void traverseIDLValueAbstractDef(IdlValue object) throws Exception{
        if(object.getInheritanceList().size() > 0){
            target.processIDLValueInheritance(object.getInheritance());
        }
        if(object.supports().size() > 0){
            target.processIDLInterfaceInheritance(object.supported());
        }
        Enumeration content = object.content();
        while(content.hasMoreElements()){
            IdlObject childObject = (IdlObject)content.nextElement();
            if(childObject          instanceof IdlTypeDef){
                target.processIDLTypeDef((IdlTypeDef)childObject);
            } else if(childObject   instanceof IdlStruct){
                target.processIDLStruct((IdlStruct)childObject);
            } else if(childObject   instanceof IdlUnion){
                target.processIDLUnion((IdlUnion)childObject);
            } else if(childObject   instanceof IdlEnum){
                target.processIDLEnum((IdlEnum)childObject);
            } else if(childObject   instanceof IdlNative){
                target.processIDLNative((IdlNative)childObject);
            } else if(childObject   instanceof IdlConst){
                target.processIDLConst((IdlConst)childObject);
            } else if(childObject   instanceof IdlExcept){
                target.processIDLExcept((IdlExcept)childObject);
            } else if(childObject   instanceof IdlAttribute){
                target.processIDLAttribute((IdlAttribute)childObject);
            } else if(childObject   instanceof IdlOp){
                target.processIDLOperation((IdlOp)childObject);
            } else {
                throw new Exception("..::IdlAbstractValueDef::..Unexpected child object type : "+childObject.getClass().getName());
            }
        }
    }

    /**
     * This method implements the functionality to traverse the IDL boxed valuetype
     * object and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8D4D007B
     */
    public void traverseIDLValueBox(IdlValueBox object) throws Exception{
        IdlObject childObject = object.type();
        if(childObject instanceof IdlSimple || childObject instanceof IdlIdent){
            target.processIDLTypeSpec(childObject);
        } else if(childObject instanceof IdlStruct){
            target.processIDLStruct((IdlStruct)childObject);
        } else if(childObject instanceof IdlUnion){
            target.processIDLUnion((IdlUnion)childObject);
        } else if(childObject instanceof IdlEnum){
            target.processIDLEnum((IdlEnum)childObject);
        }else if(childObject instanceof IdlSequence){
            target.processIDLSequence((IdlSequence)childObject);
        } else if(childObject instanceof IdlString){
            target.processIDLString((IdlString)childObject);
        } else if(childObject instanceof IdlWString){
            target.processIDLWString((IdlWString)childObject);
        } else if(childObject instanceof IdlFixed){
            target.processIDLFixed((IdlFixed)childObject);
        } else {
            throw new Exception("..::IDLValueBox::..Unexpected child object type : "+childObject.getClass().getName());
        }
        Enumeration content = object.content();
        while(content.hasMoreElements()){
            throw new Exception("..::IdlValueBox::.. Unexpected child object type : "+content.nextElement().getClass().getName());
        }
    }

    /**
     * This method implements the functionality to traverse the IDL def valuetype
     * object and will call the respective process...(..) method in the associated
     * IDLTraversable class for each child object found.
     *
     * @param object The IDL object that needs to be traversed. The process methods in
     * the target object will be called for each of this object's child elements
     * @throws Exception
     * @roseuid 40DA8D510202
     */
    public void traverseIDLValueDef(IdlValue object) throws Exception{
        if(object.getInheritanceList().size() > 0){
            target.processIDLValueInheritance(object.getInheritance());
        }
        if(object.supported().length > 0){
            target.processIDLInterfaceInheritance(object.supported());
        }
        Enumeration content = object.content();
        while(content.hasMoreElements()){
            IdlObject childObject = (IdlObject)content.nextElement();
            if(childObject          instanceof IdlTypeDef){
                target.processIDLTypeDef((IdlTypeDef)childObject);
            } else if(childObject   instanceof IdlStruct){
                target.processIDLStruct((IdlStruct)childObject);
            } else if(childObject   instanceof IdlUnion){
                target.processIDLUnion((IdlUnion)childObject);
            } else if(childObject   instanceof IdlEnum){
                target.processIDLEnum((IdlEnum)childObject);
            } else if(childObject   instanceof IdlNative){
                target.processIDLNative((IdlNative)childObject);
            } else if(childObject   instanceof IdlConst){
                target.processIDLConst((IdlConst)childObject);
            } else if(childObject   instanceof IdlExcept){
                target.processIDLExcept((IdlExcept)childObject);
            } else if(childObject   instanceof IdlAttribute){
                target.processIDLAttribute((IdlAttribute)childObject);
            } else if(childObject   instanceof IdlOp){
                target.processIDLOperation((IdlOp)childObject);
            } else if(childObject   instanceof IdlStateMember){
                target.processIDLStateMember((IdlStateMember)childObject);
            } else if(childObject   instanceof IdlFactory){
                target.processIDLFactory((IdlFactory)childObject);
            } else {
                throw new Exception("..::IdlValueDef::..Unexpected child object type : "+childObject.getClass().getName());
            }
        }
    }
}
