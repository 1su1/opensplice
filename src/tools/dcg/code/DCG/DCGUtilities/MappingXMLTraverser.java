/*
 *                         OpenSplice DDS
 *
 *   This software and documentation are Copyright 2006 to 2013 PrismTech
 *   Limited and its licensees. All rights reserved. See file:
 *
 *                     $OSPL_HOME/LICENSE 
 *
 *   for full copyright notice and license terms. 
 *
 */
package DCG.DCGUtilities;

import java.util.Vector;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Element;
import org.w3c.dom.Document;
import org.openorb.compiler.object.IdlValue;
import org.openorb.compiler.object.IdlObject;
import org.openorb.compiler.idl.reflect.idlType;
/**
 * This class provides generic functionality to traverse the Mapping XML syntax
 * tree as generated by the Xerces 2.6.2 XML DOM parser. This class also provides
 * several useful XML helper functions. Any class that wants to traverse the
 * entire or partial Mapping XML syntax tree should use the class. This class
 * allows for each object in the syntax tree that has child objects (including
 * inheritance lists etc) to be traversed correctly, without having to worry how
 * the Mapping XML tree structure works. The traversion of the Mapping XML tree
 * can start at any node in the tree by calling the specific traverse method. The
 * general starting point for tree traversal is the
 * traverseXMLMappingDLRLElement(..) method. This class also offers functionality
 * to the list of processed elements and offers functionality to browse through
 * this list. Finally this class offers functionality to change parts of the
 * Mapping XML syntax without effecting classes that are dependant on the Mapping
 * XML syntax. Changes to element and attribute names of the Mapping XML syntax is
 * made easily by the static variables defined that must be used in any class
 * working with Mapping XML information. Changes to the sequence of elements in
 * the Mapping XML can be achieved by overwritten the traverse methods. It is not
 * recommended to actually change this class!Classes that use this class must
 * implement the MappingXMLTraversable interface and call the specialized
 * constructor in this class.
 */
public class MappingXMLTraverser {

    /**
     * See variable name.
     */
    public static String associationDefElementID = "associationDef";

    /**
     * See variable name.
     */
    public static String classMappingElementID = "classMapping";

    /**
     * See variable name.
     */
    public static String classMappingNameAttributeID = "name";

    /**
     * See variable name.
     */
    public static String classMappingTargetClassNameAttributeID = "implClass";

    public static String classMappingTargetClassIncludeFilePathNameAttributeID = "implPath";

    /**
     * See variable name.
     */
    public static String compoRelationAttributeAttributeID = "attribute";

    /**
     * See variable name.
     */
    public static String compoRelationClassAttributeID = "class";

    /**
     * See variable name.
     */
    public static String compoRelationElementID = "compoRelationDef";

    /**
     * See variable name.
     */
    public static String dlrlElementID = "Dlrl";

    /**
     * See variable name.
     */
    public static String dlrlNameAttributeID = "name";

    /**
     * See variable name.
     */
    public static String enumDefElementID = "enumDef";

    /**
     * See variable name.
     */
    public static String enumDefNameAttributeID = "name";

    /**
     * See variable name.
     */
    public static String extensionTopicElementID = "extensionTopic";

    /**
     * See variable name.
     */
    public static String extensionTopicNameAttributeID = "name";
    public static String extensionTopicTypeNameAttributeID = "typename";
    /**
     * See variable name.
     */
    public static String keyDescriptionContentAttributeFullOidID = "FullOid";

    /**
     * See variable name.
     */
    public static String keyDescriptionContentAttributeID = "content";

    /**
     * See variable name.
     */
    public static String keyDescriptionContentAttributeNoOidID = "NoOid";

    /**
     * See variable name.
     */
    public static String keyDescriptionContentAttributeSimpleOidID = "SimpleOid";

    /**
     * See variable name.
     */
    public static String keyDescriptionElementID = "keyDescription";

    /**
     * See variable name.
     */
    public static String keyFieldElementID = "keyField";

    /**
     * See variable name.
     */
    public static String localElementID = "local";

    /**
     * See variable name.
     */
    public static String localNameAttributeID = "name";

    /**
     * See variable name.
     */
    public static String mainTopicElementID = "mainTopic";

    /**
     * See variable name.
     */
    public static String mainTopicNameAttributeID = "name";
    public static String mainTopicTypeNameAttributeID = "typename";

    /**
     * See variable name.
     */
    public static String monoAttributeElementID = "monoAttribute";

    /**
     * See variable name.
     */
    public static String monoAttributeNameAttributeID = "name";

    /**
     * See variable name.
     */
    public static String monoRelationElementID = "monoRelation";

    /**
     * See variable name.
     */
    public static String monoRelationNameAttributeID = "name";

    /**
     * See variable name.
     */
    public static String validityFieldElementID = "validityField";

    /**
     * See variable name.
     */
    public static String validityFieldNameAttributeID = "name";
    /**
     * See variable name.
     */
    public static String validityFieldInvalidAttributeID = "invalidValue";
    /**
     * See variable name.
     */
    public static String validityFieldValidAttributeID = "validValue";

    /**
     * See variable name.
     */
    public static String multiAttributeElementID = "multiAttribute";

    /**
     * See variable name.
     */
    public static String multiAttributeNameAttributeID = "name";

    /**
     * See variable name.
     */
    public static String multiPlaceTopicElementID = "multiPlaceTopic";

    /**
     * See variable name.
     */
    public static String multiPlaceTopicIndexAttributeID = "indexField";

    public static String topicElementIndexFieldTypeAttributeID = "indexFieldType";
    /**
     * See variable name.
     */
    public static String multiPlaceTopicNameAttributeID = "name";
    public static String multiPlaceTopicTypeNameAttributeID = "typename";

    /**
     * See variable name.
     */
    public static String multiRelationElementID = "multiRelation";

    /**
     * See variable name.
     */
    public static String multiRelationNameAttributeID = "name";

    /**
     * See variable name.
     */
    public static String placeTopicElementID = "placeTopic";

    /**
     * See variable name.
     */
    public static String placeTopicNameAttributeID = "name";
    public static String placeTopicTypeNameAttributeID = "typename";

    /**
     * Contains the list of all traversed elements
     */
    private Vector processedElements = new Vector();

    /**
     * See variable name.
     */
    public static String relationElementAttributeAttributeID = "attribute";

    /**
     * See variable name.
     */
    public static String relationElementClassAttributeID = "class";

    /**
     * See variable name.
     */
    public static String relationElementID = "relation";

    /**
     * The target class implementing the MAppingXMLTraversable interface. During tree
     * traversal the processXMLMapping...(..) methods in this object will be called.
     */
    private MappingXMLTraversable target;

    /**
     * See variable name.
     */
    public static String templateDefElementID = "templateDef";

    /**
     * See variable name.
     */
    public static String templateDefItemTypeAttributeID = "itemType";

    /**
     * See variable name.
     */
    public static String templateDefNameAttributeID = "name";

    /**
     * See variable name.
     */
    public static String templateDefPatternAttributeID = "pattern";

    /**
     * See variable name.
     */
    public static String templateDefPatternAttributeSetValueID = "Set";
    public static String templateDefPatternAttributeStrMapValueID = "StrMap";
    public static String templateDefPatternAttributeIntMapValueID = "IntMap";
    public static String templateDefPatternAttributeListValueID = "List";
    /**
     * See variable name.
     */
    public static String topicElementIndexFieldAttributeID = "indexField";

    /**
     * See variable name.
     */
    public static String topicElementNameAttributeID = "name";
    public static String topicElementTypeNameAttributeID = "typename";
    /**
     * See variable name.
     */
    public static String valueElementID = "value";

    /**
     * See variable name.
     */
    public static String valueFieldElementID = "valueField";

    public static final String isDefaultAttributeID = "xdef";
    public static final String isDefaultAttributeTrueValue = "true";
    public static final int UNKNOWN_ATTRIBUTE = -1;
    public static final int MONO_ATTRIBUTE = 0;
    public static final int MULTI_ATTRIBUTE = 1;
    public static final int MONO_RELATION = 2;
    public static final int MULTI_RELATION = 3;

    /**
     * Specialized constructor
     *
     * @param target The target class implementing the MappingXMLTraversable interface.
     * @roseuid 40DBCB6603E0
     */
    public MappingXMLTraverser(MappingXMLTraversable target){
        this.target = target;
    }

    /**
     * This method will return a Vector containing only idl types with the idlType
     * provided.
     *
     * @param nodes The orginal node list
     * @param type The idlType (from the idlTYpe reflection class) to filter
     * @return java.util.Vector
     * @roseuid 40DBD12501B0
     */
    public static Vector filterNodeList(NodeList nodes, int type){
        Vector filteredNodes = new Vector();
        for(int count = 0; count < nodes.getLength(); count++){
            Node aNode = nodes.item(count);
            if(aNode.getNodeType() == type){
                filteredNodes.add(aNode);
            }
        }
        return filteredNodes;
    }

    /**
     * Helper method that searches the processed elements list starting at the end for
     * the first occurance of an element with the provided name. If the element is not
     * found then -1 will be returned as index
     *
     * @param elementID The string representation of the element name for which the
     * index is wanted
     * @return int
     * @roseuid 40DBCB7B0074
     */
    public int getElementLastIndexInProcessedList(String elementID){
        int index = processedElements.size()-1;//the last index
        while(index >= 0){
            Element anElement = (Element)processedElements.get(index);
            if(anElement.getNodeName().equals(elementID)){
                return index;
            }
            index--;
        }
        return -1;
    }

    public static String getElementFullyExpandedTagName(Element anElement){
        StringBuffer elementTrace = new StringBuffer();
        elementTrace.append("<");
        elementTrace.append(anElement.getTagName());
        if(anElement.hasAttributes()){
            NamedNodeMap attributes = anElement.getAttributes();
            for(int count = 0; count < attributes.getLength(); count++){
                Node anAttribute = attributes.item(count);
                if(!anAttribute.getNodeName().equals(isDefaultAttributeID) && !anAttribute.getNodeName().equals(topicElementIndexFieldTypeAttributeID)){
                    if(count == 0){
                        elementTrace.append(" ");
                    }
                    elementTrace.append(anAttribute.getNodeName());
                    elementTrace.append("=\"");
                    elementTrace.append(anAttribute.getNodeValue());
                    elementTrace.append("\"");
                }
                if(count+1 != attributes.getLength() &&
                     (!attributes.item(count+1).getNodeName().equals(isDefaultAttributeID))&&
                     (!attributes.item(count+1).getNodeName().equals(topicElementIndexFieldTypeAttributeID)))
                {
                    elementTrace.append(" ");
                }
            }
        }
        if(anElement.getChildNodes().getLength() != 0){
            elementTrace.append(">");
        } else {
            elementTrace.append("/>");
        }
        return elementTrace.toString();
    }

    public static String produceElementTrace(Node node){
        return produceElementTrace(node, null);
    }

    public static String produceElementTrace(Node node, String message){
        return produceElementTrace(node, false, message);
    }
    //message may be null
    public static String produceElementTrace(Node node, boolean includeAllChildren, String message){
        StringBuffer trace = new StringBuffer();
        if(message != null){
            trace.append(message);
        }
        Vector nodes = new Vector();
        Node tmpNode = node;
        while(tmpNode != null){
            if(tmpNode.getNodeType() == Node.TEXT_NODE ){
                if(tmpNode.getTextContent().trim().length() != 0){//ignore text elements which consist of white spaces
                    nodes.add(0, tmpNode);
                }
            } else if(tmpNode.getNodeType() == Node.ELEMENT_NODE){
                nodes.add(0, tmpNode);
            }
            tmpNode = tmpNode.getParentNode();
        }
        int indent = 0;
        for(int count = 0; count < nodes.size(); count++){
            Node aNode = (Node) nodes.get(count);
            trace.append("\n");
            for(int indentCount = 0; indentCount < indent; indentCount++){
                trace.append("\t");
            }
            if(aNode.getNodeType() == Node.TEXT_NODE){
                trace.append(aNode.getTextContent());
            } else if(aNode.getNodeType() == Node.ELEMENT_NODE){
                trace.append(getElementFullyExpandedTagName((Element)aNode));
            }
            indent++;
        }
        if(includeAllChildren){
            appendChildNodesToBuffer(node, trace, indent);
        }
        return trace.toString();
    }

    public static void appendChildNodesToBuffer(Node node, StringBuffer trace, int indent){
        NodeList children =	node.getChildNodes() ;
        for(int count = 0; count < children.getLength(); count++){
            Node childNode = children.item(count);
            if(childNode.getNodeType() == Node.TEXT_NODE && childNode.getTextContent().trim().length() != 0){
                trace.append("\n");
                for(int indentCount = 0; indentCount < indent; indentCount++){
                    trace.append("\t");
                }
                trace.append(childNode.getTextContent());
            } else if(childNode.getNodeType() == Node.ELEMENT_NODE){
                trace.append("\n");
                for(int indentCount = 0; indentCount < indent; indentCount++){
                    trace.append("\t");
                }
                trace.append(getElementFullyExpandedTagName((Element)childNode));
            }
            if(childNode.hasChildNodes()){
                appendChildNodesToBuffer(childNode, trace, indent+1);
            }
        }
    }

    /**
     * Helper method that returns the name of the last topic element found in the
     * processed elements list. The name returned belongs to a place topic, multiplace
     * topic, extension topic or main topic element (in that sequence) May return NULL
     * @return String
     * @roseuid 40DC185500FD
     */
    public String getLastTopicName() {
        //There are four types of elements in the mapping XML that can contain the topic name. These topic names have the following ranking. The place topic or multi place topic are always used if they are found as the last topic element in the processed elements list in thge xml traverser. if neither element is found then the extension topic element is next. and finally the main topic element is used as topic name. This method will return null if no topic element is found!
        int index = -1;
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.placeTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            return MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.placeTopicNameAttributeID);
        }
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.multiPlaceTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            return MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.multiPlaceTopicNameAttributeID);
        }
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.extensionTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            return MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.extensionTopicNameAttributeID);
        }
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.mainTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            return MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.mainTopicNameAttributeID);
        }
        return null;
    }
    /**
     * Helper method that returns the name (in idl fully qualified format) of the last topic element found in the
     * processed elements list. The name returned belongs to a place topic, multiplace
     * topic, extension topic or main topic element (in that sequence) May return NULL
     * @return String
     * @roseuid 40DC185500FD
     */
    public String getLastTopicIdlName() {
        //There are four types of elements in the mapping XML that can contain the topic name. These topic names have the following ranking. The place topic or multi place topic are always used if they are found as the last topic element in the processed elements list in thge xml traverser. if neither element is found then the extension topic element is next. and finally the main topic element is used as topic name. This method will return null if no topic element is found!
        String value;
        int index = -1;
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.placeTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            value = MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.placeTopicTypeNameAttributeID);
            if(value == null){
                value = MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.placeTopicNameAttributeID);
            }
            return value;
        }
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.multiPlaceTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            value = MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.multiPlaceTopicTypeNameAttributeID);
            if(value == null){
                value = MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.multiPlaceTopicNameAttributeID);
            }
            return value;
        }
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.extensionTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            value = MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.extensionTopicTypeNameAttributeID);
            if(value == null){
                value = MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.extensionTopicNameAttributeID);
            }
            return value;
        }
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.mainTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            value = MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.mainTopicTypeNameAttributeID);
            if(value == null){
                value = MappingXMLTraverser.getNodeValue(topicElement.getAttributes(), MappingXMLTraverser.mainTopicNameAttributeID);
            }
            return value;
        }
        return null;
    }

    public boolean isLastTopicDefault(){
        //There are four types of elements in the mapping XML that can contain the topic name.
        //These topic names have the following ranking. The place topic or multi place topic are always used if
        //they are found as the last topic element in the processed elements list in thge xml traverser.
        //if neither element is found then the extension topic element is next. and finally the main topic element
        //is used as topic name. This method will return null if no topic element is found!
        String value;
        int index = -1;
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.placeTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            return isElementDefault(topicElement);
        }
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.multiPlaceTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            return isElementDefault(topicElement);
        }
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.extensionTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            return isElementDefault(topicElement);
        }
        index = getElementLastIndexInProcessedList(MappingXMLTraverser.mainTopicElementID);
        if(index != -1){
            Element topicElement = getProcessedElement(index);
            return isElementDefault(topicElement);
        }
        return false;
    }

    /**
     * This method is a helper method to easily return the value of a node. May return
     * NULL
     *
     * @param attributes The map containing the attributes to be searched
     * @param attributeID The id of the attribute wanted
     * @return String
     * @roseuid 40DBD12801A0
     */
    public static String getNodeValue(NamedNodeMap attributes, String attributeID){
        String nodeValue = null;
        Node aNode = attributes.getNamedItem(attributeID);
        if(aNode != null){
            nodeValue = getNodeValue(aNode);
        }
        return nodeValue;
    }

     public static String getNodeValue(Node node) {
         if (null == node)
             return null;
         String value = node.getNodeValue();
         if (null == value)
             return null;
         return value.replaceAll("\\b_", "");//replaces all '_' which follow a 'word boundary'

     }

    public static String removeQualification(String qualifiedName){
        String returnValue = qualifiedName;
        int qualifierIndex = returnValue.indexOf(":");
        while((qualifierIndex != -1) && ((qualifierIndex+1) < returnValue.length())){
            returnValue = returnValue.substring(qualifierIndex+1, returnValue.length());
            qualifierIndex = returnValue.indexOf(":");
        }
        return returnValue;
    }


    /**
     * Returns the element identified by the index number provided from the processed
     * elements list
     *
     * @param index The index of the element in the processed elements list
     * @return Element
     * @roseuid 40DBCB7102A7
     */
    public Element getProcessedElement(int index){
        return (Element)processedElements.get(index);
    }

    /**
     * Returns the current size of the processed elements list
     * @return int
     * @roseuid 40DBCB770372
     */
    public int getProcessedElementsSize(){
        return processedElements.size();
    }

    /**
     * Returns all child, grandchild, etc elements of the XML element provided that
     * match the provided name.
     *
     * @param parentElement The XML element that will be the starting point of the
     * search
     * @param elementID The tag name of the elements to find
     * @return NodeList
     * @roseuid 40DBD12B0346
     */
    public static NodeList getXMLAllChildElements(Element parentElement, String elementID) {
        return parentElement.getElementsByTagName(elementID);
    }

    /**
     * return grandchildren etc. May return an empty vector if no matching elements
     * were found.
     *
     * @param parentElement The XML element from which to start the search for the
     * child elements.
     * @param elementID The tag name of the elements to return
     * @return java.util.Vector
     * @roseuid 40DBD12E02BA
     */
    public static Vector getXMLDirectChildElements(Element parentElement, String elementID) {
        Vector matchingChildren =  new Vector();
        NodeList children = parentElement.getChildNodes();
        for(int count = 0; count < children.getLength(); count++){
            Node aNode = children.item(count);
            if(aNode.getNodeName().equals(elementID)){
                matchingChildren.add(aNode);
            }
        }
        return matchingChildren;
    }

    /**
     * Returns the value of the attribute for the provided element. May also return
     * null;
     *
     * @param sourceElement The target element to search for the attribute in.
     * @param attributeID The attribute name of which the value needs to be returned
     * @return String
     * @roseuid 40DBD13102BA
     */
    public static String getXMLElementAttributeValue(Node sourceElement, String attributeID) {
        if(sourceElement.hasAttributes()){
            NamedNodeMap attributes = sourceElement.getAttributes();
            Node attr = attributes.getNamedItem(attributeID);
            if(attr != null){
                return MappingXMLTraverser.getNodeValue(attr);//can be null
            }
        }
        return null;
    }

    /**
     * Return the first XML element found with the element id, attribute id and
     * attribute value specified. Starts it's search from the parent element provided
     *
     * @param parentElement The element from which the search is started
     * @param elementID The tag name identifying the element wanted
     * @param attributeID The attribute name identifying the attribute wanted
     * @param attributeValue The value of the attribute wanted
     * @return Element
     * @roseuid 40DBD135026C
     */
    public static Element getXMLElementWithAttributeValue(Element parentElement, String elementID, String attributeID, String attributeValue) {
        NodeList elements = parentElement.getElementsByTagName(elementID);
        for(int count = 0; count < elements.getLength(); count++){
            Element node = (Element)elements.item(count);
            if(node.hasAttributes()){
                NamedNodeMap attributes = node.getAttributes();
                Node anAttribute = attributes.getNamedItem(attributeID);
                if(anAttribute !=null){
                    String currentAttributeValue = MappingXMLTraverser.getNodeValue(anAttribute);
                    if(currentAttributeValue!=null && attributeValue.equalsIgnoreCase(currentAttributeValue)){
                        return node;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Returns the first element with the specified name (there might be other
     * elements with that name that will not be found.) To find multiple elements with
     * the same tag name use: getXMLAllChildElements(Element parentElement, String
     * elementID) or getXMLDirectChildElements.This method is case insensitive and
     * will not search deeper then the direct child elements. May also return NULL.
     *
     * @param parentElement The XML element from which the search for the element will
     * be started
     * @param elementID The tag name of the wanted element
     * @return Element
     * @roseuid 40DBD1380346
     */
    public static Element getXMLFirstChildElementWithNameIgnoreCase(Element parentElement, String elementID) {
        NodeList elements = parentElement.getChildNodes();
        for(int count = 0; count < elements.getLength(); count++){
            Node node = (Node)elements.item(count);
            if(node.getNodeType() == Node.ELEMENT_NODE && ((Element)node).getTagName().equalsIgnoreCase(elementID)){
                return (Element)node;
            }
        }
        return null;
    }

    /**
     * Return the value of the attribute from the first XML element found with the
     * element id and attribute id specified. Starts it's search from the parent
     * element provided
     *
     * @param parentElement The element from which the search is started
     * @param elementID The tag name identifying the element wanted
     * @param attributeID The attribute name identifying the attribute wanted
     * @return java.lang.String
     * @roseuid 40DBD13E0395
     */
    public static String getXMLFirstElementAttributeValue(Element parentElement, String elementID, String attributeID){
        NodeList elements = parentElement.getElementsByTagName(elementID);
        for(int count = 0; count < elements.getLength(); count++){
            Element node = (Element)elements.item(count);
            if(node.hasAttributes()){
                NamedNodeMap attributes = node.getAttributes();
                Node attr = attributes.getNamedItem(attributeID);
                if(attr != null){
                    return MappingXMLTraverser.getNodeValue(attr);//can be null
                }
            }
        }
        return null;
    }

    public static Element findClassMappingwithName(Document rootXML, String nameFQ){
        return findElement(rootXML, classMappingElementID, classMappingNameAttributeID, nameFQ);
    }

    public static Element findTemplateDefWithName(Document rootXML, String name) throws Exception{
        return findElement(rootXML, templateDefElementID, templateDefNameAttributeID, name);
    }

    public static Element getKeydescriptionElement(Element element) throws Exception{
        return getXMLFirstChildElementWithNameIgnoreCase(element, keyDescriptionElementID);
    }

    public static Element getMultiPlaceTopic(Element element) throws Exception{
        return getXMLFirstChildElementWithNameIgnoreCase(element, multiPlaceTopicElementID);
    }

    public static boolean isElementDefault(Node element){
        String value = getXMLElementAttributeValue(element, isDefaultAttributeID);
        if(value != null && value.equals(isDefaultAttributeTrueValue)){
            return true;
        }
        return false;
    }

    public static Element getAttributeMapping(Element classMapping, String attributeName){
        Element attrElement;

        attrElement = MappingXMLTraverser.getXMLElementWithAttributeValue(classMapping,
                       MappingXMLTraverser.localElementID, MappingXMLTraverser.localNameAttributeID, attributeName);
        if(attrElement != null){
            return attrElement;
        }
        attrElement = MappingXMLTraverser.getXMLElementWithAttributeValue(classMapping,
                        MappingXMLTraverser.monoAttributeElementID, MappingXMLTraverser.monoAttributeNameAttributeID,
                        attributeName);
        if(attrElement != null){
            return attrElement;
        }
        attrElement = MappingXMLTraverser.getXMLElementWithAttributeValue(classMapping,
                        MappingXMLTraverser.monoRelationElementID, MappingXMLTraverser.monoRelationNameAttributeID,
                        attributeName);
        if(attrElement != null){
            return attrElement;
        }
        attrElement = MappingXMLTraverser.getXMLElementWithAttributeValue(classMapping,
                        MappingXMLTraverser.multiAttributeElementID, MappingXMLTraverser.multiAttributeNameAttributeID,
                        attributeName);
        if(attrElement != null){
            return attrElement;
        }
        attrElement = MappingXMLTraverser.getXMLElementWithAttributeValue(classMapping,
                        MappingXMLTraverser.multiRelationElementID, MappingXMLTraverser.multiRelationNameAttributeID,
                        attributeName);
        if(attrElement != null){
            return attrElement;
        }
        return null;
    }

    private static Element findElement(Document rootXML, String elementID, String attributeID, String attributeValue){
        NodeList elements;
        int count;
        Element node;
        NamedNodeMap attributes;
        Node attr;
        String value;

        elements = rootXML.getElementsByTagName(elementID);
        for(count = 0; count < elements.getLength(); count++){
            node = (Element)elements.item(count);
            if(node.hasAttributes()){
                attributes = node.getAttributes();
                attr = attributes.getNamedItem(attributeID);
                if(attr != null){
                    value = MappingXMLTraverser.getNodeValue(attr);//can be null
                    if(value != null && value.equals(attributeValue)){
                        return node;
                    }
                }
            }
        }
        return null;
    }

    public static Element getMainTopicElementForClassMapping(Element classMapping) throws Exception{
        Vector childElements = getXMLDirectChildElements(classMapping, mainTopicElementID);
        if(childElements.size() > 1){
            throw new Exception(MappingXMLTraverser.produceElementTrace((Node)classMapping,
                "Invalid number of "+mainTopicElementID+" child elements detected (zero or one allowed)!"));
        }
        if(childElements.size() == 1){
            return (Element)childElements.get(0);
        }
        return null;
    }

    public static String getKeyFieldName(Element keyField) throws Exception{
        Vector childNodes = filterNodeList(keyField.getChildNodes(), Node.TEXT_NODE);
        if(childNodes.size() > 1){
            throw new Exception(MappingXMLTraverser.produceElementTrace((Node)keyField, true,
                                        "Multiple text field nodes detected in keyfield. Expected one"));
        }
        if(childNodes.size() == 0){
            throw new Exception(MappingXMLTraverser.produceElementTrace((Node)keyField, true,
                                                                                        "Missing #PCDATA in keyfield"));
        }
        Node childNode = (Node)childNodes.get(0);
        String name = MappingXMLTraverser.getNodeValue(childNode);
        if(name == null){
            throw new Exception(MappingXMLTraverser.produceElementTrace((Node)keyField, true,
                                                                                        "Missing #PCDATA in keyfield"));
        }
        return name;

    }

    public static int validateTemplateDefItemType(Vector rootDLRLIDL, Element templateDef, String itemType) throws Exception {
        if(itemType.equals("boolean") || itemType.equals("char") || itemType.equals("double")
            || itemType.equals("float") || itemType.equals("long") || itemType.equals("long long")
            || itemType.equals("octet") || itemType.equals("short") || itemType.equals("string")
            || itemType.equals("unsigned short") || itemType.equals("unsigned long")
            || itemType.equals("unsigned long long")){
            return MULTI_ATTRIBUTE;
        } else {
            IdlObject object = IDLTraverser.getIdlNonForwardValueWithFullyQualifiedName(rootDLRLIDL, itemType);
            if(object != null){
                if(!IDLTraverser.valuetypeInheritsFromObjectRoot((IdlValue)object)){
                    throw new Exception(MappingXMLTraverser.produceElementTrace((Node)templateDef,
                        "The "+MappingXMLTraverser.templateDefItemTypeAttributeID+" attribute indicates a valuetype '"+
                        itemType+"' as target type. However the valuetype does not inherit from DDS::ObjectRoot as "+
                        "required."));
                }
                return MULTI_RELATION;
            } else {
                int[] types = new int[3];
                types[0] = idlType.STRUCT;
                types[1] = idlType.UNION;
                types[2] = idlType.ENUM;
                object = IDLTraverser.getIdlObjectWithFullyQualifiedName(rootDLRLIDL, types, itemType);
                if(object!=null){
                    return MULTI_ATTRIBUTE;
                }
            }
        }
        throw new Exception(MappingXMLTraverser.produceElementTrace((Node)templateDef,
                "Invalid value '"+itemType+"' for "+MappingXMLTraverser.templateDefItemTypeAttributeID+
                " attribute specified! The following values are allowed: boolean, char, double, float, long, "+
                "long long, octet, short, string, unsigned short, unsigned short, unsigned long, "+
                "unsigned long long. Scoped IDL names of valuetypes, structs, unions and enums are also allowed."+
                "The Sequence type is not a supported "+MappingXMLTraverser.templateDefItemTypeAttributeID+
                " value. This includes anonymous sequences."));

    }
    /**
     * Removes all elements contained within the processed elements list including the
     * element at the index location.
     *
     * @param index The index point in the processed elements list from which the
     * elements need to be removed
     * @roseuid 40DBCBD90054
     */
    public void removeProcessedElementsFromListFromIndex(int index){
        while(processedElements.size() > index){
            processedElements.remove(index);
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML
     * associationDef element and will call the respective process...(..) method in
     * the associated MappingXMLTraversable class for each child object found.
     * @param associationDefElement
     * @throws Exception
     * @roseuid 40DBCBE400C1
     */
    public void traverseXMLMappingAssociationDefElement(Element associationDefElement) throws Exception {
        processedElements.add(associationDefElement);
        Vector childNodes = filterNodeList(associationDefElement.getChildNodes(), Node.ELEMENT_NODE);
        for(int count = 0; count < childNodes.size(); count++){
            Element childNode = (Element)childNodes.get(count);
            String nodeName = childNode.getNodeName();
            if(nodeName.equals(relationElementID)){
                target.processXMLMappingRelationElement(childNode);
            } else {
                throw new Exception("\tUnexpected child element '"+nodeName+"'. Allowed elements: "+relationElementID);
            }
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML
     * classMapping  element and will call the respective process...(..) method in the
     * associated MappingXMLTraversable class for each child object found.
     *
     * @param classMappingElement The Mapping XML element that needs to be traversed.
     * The process methods in the target object will be called for each of this
     * elements child elements
     * @throws Exception
     * @roseuid 40DBD0F202F8
     */
    public void traverseXMLMappingClassMappingElement(Element classMappingElement) throws Exception {
        processedElements.add(classMappingElement);
        Vector childNodes = filterNodeList(classMappingElement.getChildNodes(), Node.ELEMENT_NODE);
        for(int count = 0; count < childNodes.size(); count++){
            Element childNode = (Element)childNodes.get(count);
            String nodeName = childNode.getNodeName();
            if(nodeName.startsWith(mainTopicElementID)){
                target.processXMLMappingMainTopicElement(childNode);
            } else if (nodeName.startsWith(localElementID)) {
                target.processXMLMappingLocalElement(childNode);
            } else if (nodeName.startsWith(extensionTopicElementID)) {
                target.processXMLMappingExtensionTopicElement(childNode);
            } else if (nodeName.startsWith(monoAttributeElementID)) {
                target.processXMLMappingMonoAttributeElement(childNode);
            } else if (nodeName.startsWith(multiAttributeElementID))    {
                target.processXMLMappingMultiAttributeElement(childNode);
            } else if (nodeName.startsWith(monoRelationElementID))  {
                target.processXMLMappingMonoRelationElement(childNode);
            } else if (nodeName.equals(multiRelationElementID)) {
                target.processXMLMappingMultiRelationElement(childNode);
            } else {
                throw new Exception("\tUnexpected child element '"+nodeName+"'. Allowed elements: "+mainTopicElementID+"? , "+extensionTopicElementID+"? , ("+localElementID+" |  | "+monoAttributeElementID+" | "+multiAttributeElementID+" | "+monoRelationElementID+" | "+multiRelationElementID+")*");
            }
        }

    }

    /**
     * This method implements the functionality to traverse the Mapping XML dlrl
     * element and will call the respective process...(..) method in the associated
     * MappingXMLTraversable class for each child object found.
     *
     * @param dlrlElement The Mapping XML element that needs to be traversed. The
     * process methods in the target object will be called for each of this elements
     * child elements
     * @throws Exception
     * @roseuid 40DBCBDD0083
     */
    public void traverseXMLMappingDLRLElement(Element dlrlElement) throws Exception {
        processedElements.add(dlrlElement);
        Vector childNodes = filterNodeList(dlrlElement.getChildNodes(), Node.ELEMENT_NODE);
        for(int count = 0; count < childNodes.size(); count++){
            Element childNode = (Element)childNodes.get(count);
            String nodeName = childNode.getNodeName();
            if(nodeName.equals(enumDefElementID)){
                //it is an enumDef
                target.processXMLMappingEnumDefElement(childNode);
            } else if(nodeName.equals(templateDefElementID)){
                //it is a templateDef
                target.processXMLMappingTemplateDefElement(childNode);
            } else if(nodeName.equals(associationDefElementID)){
                //it is a associationDef
                target.processXMLMappingAssociationDefElement(childNode);
            } else if(nodeName.equals(compoRelationElementID)){
                //it is a compoRelationDef
                target.processXMLMappingCompoRelationDefElement(childNode);
            } else if(nodeName.equals(classMappingElementID)){
                //it is a classMapping
                target.processXMLMappingClassMappingElement(childNode);
            } else {
                throw new Exception("\tUnexpected child element '"+nodeName+"'. Allowed elements: "+enumDefElementID+" | "+templateDefElementID+" | "+associationDefElementID+" | "+compoRelationElementID+"| "+classMappingElementID+"");
            }
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML enumDef
     * element and will call the respective process...(..) method in the associated
     * MappingXMLTraversable class for each child object found.
     *
     * @param enumDefElement The Mapping XML element that needs to be traversed. The
     * process methods in the target object will be called for each of this elements
     * child elements
     * @throws Exception
     * @roseuid 40DBCBE00209
     */
    public void traverseXMLMappingEnumDefElement(Element enumDefElement) throws Exception {
        processedElements.add(enumDefElement);
        Vector childNodes = filterNodeList(enumDefElement.getChildNodes(), Node.ELEMENT_NODE);
        for(int count = 0; count < childNodes.size(); count++){
            Element childNode = (Element)childNodes.get(count);
            String nodeName = childNode.getNodeName();
            if(nodeName.equals(valueElementID)){
                target.processXMLMappingValueElement(childNode);
            } else {
                throw new Exception("\tUnexpected child element '"+nodeName+"'. Allowed elements: "+valueElementID);
            }
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML
     * extensionTopic element and will call the respective process...(..) method in
     * the associated MappingXMLTraversable class for each child object found.
     *
     * @param extensionTopicElement The Mapping XML element that needs to be
     * traversed. The process methods in the target object will be called for each of
     * this elements child elements
     * @throws Exception
     * @roseuid 40DBD0F901B0
     */
    public void traverseXMLMappingExtensionTopicElement(Element extensionTopicElement) throws Exception {
        traverseXMLMappingTopicElement(extensionTopicElement);
    }

    /**
     * This method implements the functionality to traverse the Mapping XML
     * keyDescription element and will call the respective process...(..) method in
     * the associated MappingXMLTraversable class for each child object found.
     *
     * @param keyDescriptionElement The Mapping XML element that needs to be
     * traversed. The process methods in the target object will be called for each of
     * this elements child elements
     * @throws Exception
     * @roseuid 40DBD1180346
     */
    public void traverseXMLMappingKeyDescriptionElement(Element keyDescriptionElement) throws Exception {
        processedElements.add(keyDescriptionElement);
        Vector childNodes = filterNodeList(keyDescriptionElement.getChildNodes(), Node.ELEMENT_NODE);
        for(int count = 0; count < childNodes.size(); count++){
            Element childNode = (Element)childNodes.get(count);
            String nodeName = childNode.getNodeName();
            if(nodeName.equals(keyFieldElementID)){
                target.processXMLMappingKeyFieldElement(childNode);
            } else {
                throw new Exception("\tUnexpected child element '"+nodeName+"'. Allowed elements: "+keyFieldElementID);
            }
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML keyField
     * element and will call the respective process...(..) method in the associated
     * MappingXMLTraversable class for each child object found.
     *
     * @param keyFieldElement The Mapping XML element that needs to be traversed. The
     * process methods in the target object will be called for each of this elements
     * child elements
     * @throws Exception
     * @roseuid 40DBD11C0049
     */
    public void traverseXMLMappingKeyFieldElement(Element keyFieldElement) throws Exception {
        processedElements.add(keyFieldElement);
        Vector childNodes = filterNodeList(keyFieldElement.getChildNodes(), Node.TEXT_NODE);
        if(childNodes.size() > 0){
            for(int count = 0; count < childNodes.size(); count++){
                Node childNode = (Node)childNodes.get(count);
                target.processXMLMappingKeyFieldTextElement(childNode);
            }
        } else {
            throw new Exception("\tNo text child nodes found. Expected one or more (text) child nodes");
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML mainTopic
     * element and will call the respective process...(..) method in the associated
     * MappingXMLTraversable class for each child object found.
     *
     * @param mainTopicElement The Mapping XML element that needs to be traversed. The
     * process methods in the target object will be called for each of this elements
     * child elements
     * @throws Exception
     * @roseuid 40DBD0F5023C
     */
    public void traverseXMLMappingMainTopicElement(Element mainTopicElement) throws Exception {
        traverseXMLMappingTopicElement(mainTopicElement);
    }

    /**
     * This method implements the functionality to traverse the Mapping XML
     * monoAttribute element and will call the respective process...(..) method in the
     * associated MappingXMLTraversable class for each child object found.
     *
     * @param monoAttributeElement The Mapping XML element that needs to be traversed.
     * The process methods in the target object will be called for each of this
     * elements child elements
     * @throws Exception
     * @roseuid 40DBD10D00C5
     */
    public void traverseXMLMappingMonoAttributeElement(Element monoAttributeElement) throws Exception {
        processedElements.add(monoAttributeElement);
        Vector childNodes = filterNodeList(monoAttributeElement.getChildNodes(), Node.ELEMENT_NODE);
        for(int count = 0; count < childNodes.size(); count++){
            Element childNode = (Element)childNodes.get(count);
            String nodeName = childNode.getNodeName();
            if(nodeName.equals(placeTopicElementID)){
                target.processXMLMappingPlaceTopicElement(childNode);
            } else if(nodeName.equals(valueFieldElementID)){
                target.processXMLMappingValueFieldElement(childNode);
            } else {
                throw new Exception("\tUnexpected child element '"+nodeName+"'. Allowed elements: "+placeTopicElementID+" | "+valueFieldElementID);
            }
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML
     * monoRelation element and will call the respective process...(..) method in the
     * associated MappingXMLTraversable class for each child object found.
     *
     * @param monoRelationElement The Mapping XML element that needs to be traversed.
     * The process methods in the target object will be called for each of this
     * elements child elements
     * @throws Exception
     * @roseuid 40DBD1130097
     */
    public void traverseXMLMappingMonoRelationElement(Element monoRelationElement) throws Exception {
        processedElements.add(monoRelationElement);
        Vector childNodes = filterNodeList(monoRelationElement.getChildNodes(), Node.ELEMENT_NODE);
        for(int count = 0; count < childNodes.size(); count++){
            Element childNode = (Element)childNodes.get(count);
            String nodeName = childNode.getNodeName();
            if(nodeName.equals(placeTopicElementID)){
                target.processXMLMappingPlaceTopicElement(childNode);
            } else if(nodeName.equals(keyDescriptionElementID)){
                target.processXMLMappingKeyDescriptionElement(childNode);
            } else if(nodeName.equals(validityFieldElementID)){
                target.processXMLMappingValidityFieldElement(childNode);
            } else {
                throw new Exception("\tUnexpected child element '"+nodeName+"'. Allowed elements: "+placeTopicElementID+" | "+keyDescriptionElementID+" | "+validityFieldElementID);
            }
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML
     * multiAttribute element and will call the respective process...(..) method in
     * the associated MappingXMLTraversable class for each child object found.
     *
     * @param multiAttributeElement The Mapping XML element that needs to be
     * traversed. The process methods in the target object will be called for each of
     * this elements child elements
     * @throws Exception
     * @roseuid 40DBD1100039
     */
    public void traverseXMLMappingMultiAttributeElement(Element multiAttributeElement) throws Exception {
        processedElements.add(multiAttributeElement);
        Vector childNodes = filterNodeList(multiAttributeElement.getChildNodes(), Node.ELEMENT_NODE);
        for(int count = 0; count < childNodes.size(); count++){
            Element childNode = (Element)childNodes.get(count);
            String nodeName = childNode.getNodeName();
            if(nodeName.equals(multiPlaceTopicElementID)){
                target.processXMLMappingMultiPlaceTopicElement(childNode);
            } else if(nodeName.equals(valueFieldElementID)){
                target.processXMLMappingValueFieldElement(childNode);
            } else {
                throw new Exception("\tUnexpected child element '"+nodeName+"'. Allowed elements: "+multiPlaceTopicElementID+" | "+valueFieldElementID);
            }
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML
     * multiPlaceTopic element and will call the respective process...(..) method in
     * the associated MappingXMLTraversable class for each child object found.
     *
     * @param multiPlaceTopicElement The Mapping XML element that needs to be
     * traversed. The process methods in the target object will be called for each of
     * this elements child elements
     * @throws Exception
     * @roseuid 40DBD107000A
     */
    public void traverseXMLMappingMultiPlaceTopicElement(Element multiPlaceTopicElement) throws Exception {
        traverseXMLMappingTopicElement(multiPlaceTopicElement);
    }

    /**
     * This method implements the functionality to traverse the Mapping XML
     * multiRelation element and will call the respective process...(..) method in the
     * associated MappingXMLTraversable class for each child object found.
     *
     * @param multiRelationElement The Mapping XML element that needs to be traversed.
     * The process methods in the target object will be called for each of this
     * elements child elements
     * @throws Exception
     * @roseuid 40DBD1160123
     */
    public void traverseXMLMappingMultiRelationElement(Element multiRelationElement) throws Exception {
        processedElements.add(multiRelationElement);
        Vector childNodes = filterNodeList(multiRelationElement.getChildNodes(), Node.ELEMENT_NODE);
        for(int count = 0; count < childNodes.size(); count++){
            Element childNode = (Element)childNodes.get(count);
            String nodeName = childNode.getNodeName();
            if(nodeName.equals(multiPlaceTopicElementID)){
                target.processXMLMappingMultiPlaceTopicElement(childNode);
            } else if(nodeName.equals(keyDescriptionElementID)){
                target.processXMLMappingKeyDescriptionElement(childNode);
            } else {
                throw new Exception("\tUnexpected child element '"+nodeName+"'. Allowed elements: "+multiPlaceTopicElementID+" | "+keyDescriptionElementID);
            }
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML placeTopic
     * element and will call the respective process...(..) method in the associated
     * MappingXMLTraversable class for each child object found.
     *
     * @param placeTopicElement The Mapping XML element that needs to be traversed.
     * The process methods in the target object will be called for each of this
     * elements child elements
     * @throws Exception
     * @roseuid 40DBD0FC00F4
     */
    public void traverseXMLMappingPlaceTopicElement(Element placeTopicElement) throws Exception {
        traverseXMLMappingTopicElement(placeTopicElement);
    }

    /**
     * This method implements the functionality to traverse the Mapping XML topic
     * element and will call the respective process...(..) method in the associated
     * MappingXMLTraversable class for each child object found. This method is used
     * underwater to traverse the multi place, place, main and extension topic
     * elements, as they all have the same child element structure.
     *
     * @param topicElement The Mapping XML element that needs to be traversed. The
     * process methods in the target object will be called for each of this elements
     * child elements
     * @throws Exception
     * @roseuid 40DBD10A0104
     */
    private void traverseXMLMappingTopicElement(Element topicElement) throws Exception {
        processedElements.add(topicElement);
        Vector childNodes = filterNodeList(topicElement.getChildNodes(), Node.ELEMENT_NODE);
        for(int count = 0; count < childNodes.size(); count++){
            Element childNode = (Element)childNodes.get(count);
            String nodeName = childNode.getNodeName();
            if(nodeName.equals(keyDescriptionElementID)){
                target.processXMLMappingKeyDescriptionElement(childNode);
            } else {
                throw new Exception("\tUnexpected child element '"+nodeName+"'. Allowed elements: "+keyDescriptionElementID);
            }
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML value
     * element and will call the respective process...(..) method in the associated
     * MappingXMLTraversable class for each child object found.
     *
     * @param valueElement The Mapping XML element that needs to be traversed. The
     * process methods in the target object will be called for each of this elements
     * child elements
     * @throws Exception
     * @roseuid 40DBD121026B
     */
    public void traverseXMLMappingValueElement(Element valueElement) throws Exception {
        processedElements.add(valueElement);
        Vector childNodes = filterNodeList(valueElement.getChildNodes(), Node.TEXT_NODE);
        if(childNodes.size() > 0){
            for(int count = 0; count < childNodes.size(); count++){
                Node childNode = (Node)childNodes.get(count);
                target.processXMLMappingValueTextElement(childNode);
            }
        } else {
            throw new Exception("\tNo text child nodes found. Expected one or more (text) child nodes");
        }
    }

    /**
     * This method implements the functionality to traverse the Mapping XML valueField
     * element and will call the respective process...(..) method in the associated
     * MappingXMLTraversable class for each child object found.
     *
     * @param valueFieldElement The Mapping XML element that needs to be traversed.
     * The process methods in the target object will be called for each of this
     * elements child elements
     * @throws Exception
     * @roseuid 40DBD11F000A
     */
    public void traverseXMLMappingValueFieldElement(Element valueFieldElement) throws Exception {
        processedElements.add(valueFieldElement);
        Vector childNodes = filterNodeList(valueFieldElement.getChildNodes(), Node.TEXT_NODE);
        if(childNodes.size() > 0){
            for(int count = 0; count < childNodes.size(); count++){
                Node childNode = (Node)childNodes.get(count);
                target.processXMLMappingValueFieldTextElement(childNode);
            }
        } else {
            throw new Exception("\tNo text child nodes found. Expected one or more (text) child nodes");
        }
    }
}
