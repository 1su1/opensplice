/*
 *                         OpenSplice DDS
 *
 *   This software and documentation are Copyright 2006 to 2013 PrismTech
 *   Limited and its licensees. All rights reserved. See file:
 *
 *                     $OSPL_HOME/LICENSE 
 *
 *   for full copyright notice and license terms. 
 *
 */
#ifndef CCPP_OBJECTHOME_H
#define CCPP_OBJECTHOME_H

#include "ccpp_dlrl.h"
#include "ccpp_DlrlUtils.h"
#include "DLRL_Kernel.h"
#include "ccpp_Cache_impl.h"
#include "ccpp_dlrl_if.h"
/* !!!!!!!!NOTE From here no more includes are allowed!!!!!!! */

namespace DDS
{

    class Selection_impl;

    /**
     * <P>For each application defined class there is an ObjectHome instance,
     * which exists to globally represent the related set of instances and to
     * perform actions on it. Actually, ObjectHome is the abstract root class
     * for specialized implementation classes that are generated by the DLRL
     * code generator. The name for such a derived class is FooHome, assuming it
     * corresponds to the application-defined class Foo. Each of these
     * specialized homes is dedicated to one application-defined class, so that
     * it completely embeds the related specificity. </P>
     * <P>ObjectHomes and their typed specializations have no corresponding
     * factory, they must be instantiated directly by the application, using a
     * default constructor without any parameters. Instantiating an ObjectHome
     * like that initializes all attributes to their default settings, (which
     * will be mentioned below). </P>
     * <P>When an ObjectHome has been created, it must be registered to a Cache
     * before it can be used to actually manage DLRL Objects of its related
     * type.
     * The only operations that may be invoked on an unregistered home are the
     * accessors to obtain the name of the class that it is supposed to manage
     * (name), the value of the auto_deref attribute (auto_deref) and the SQL
     * expression for the filter (content_filter). It is also allowed to change
     * this filter expression (set_content_filter) and to change the value of
     * the auto_deref attribute (set_auto_deref). </P>
     * <P>After all homes are registered to a Cache, the Cache needs to
     * register_all_for_pub_sub, thus connecting each home to the underlying
     * DCPS infrastructure. During this step, the Cache will also resolve all
     * relationships between homes. In the case that one DLRL class inherits
     * from another one, both their corresponding homes will be connected. It
     * is possible to navigate from the home of the child class to the home of
     * its parent class (parent), or to navigate from the home of a parent
     * class to the homes of all its possible child-classes (children).</P>
     * <P>A home manages the state of all DLRL Objects of its corresponding
     * type. With respect to incoming data, it can choose to always copy that
     * data into the corresponding DLRL objects (auto_deref =
     * <code>true</code>), or it can delay that step until the user actually
     * tries to access the state of a DLRL object (auto_deref =
     * <code>false</code>). This behaviour is not only determined by the value
     * of the auto_deref attribute, but it can also be performed on application
     * request for all objects managed by this home: deref_all loads all DCPS
     * data into the DLRL objects of the corresponding type and underef_all
     * unloads this data from all DLRL objects of the corresponding type.</P>
     * <P>To find out how information is distributed through the DCPS, it is
     * necessary to know which attribute is mapped onto which topic. The
     * operation get_all_topic_names returns the names of all topics that are
     * mapped onto this object, the operation get_topic_name returns the name
     * of the topic that holds the value for the specified attribute.</P>
     * <P>Finally, when a Cache is deleted, all ObjectHomes attached to it will
     * also be considered deleted. Invoking any operation on such a home will
     * result in an AlreadyDeleted exception being thrown.</P>
     */
    class OS_DLRL_API ObjectHome_impl :
        public virtual DDS::ObjectHome,
        public LOCAL_REFCOUNTED_OBJECT
    {

        friend class DDS::Cache_impl;

        friend void
            ::ccpp_DCPSUtilityBridge_us_registerType(
                DLRL_Exception* exception,
                void* userData,
                DK_ObjectHomeAdmin* home,
                DK_CacheAdmin* cache,
                LOC_char* topicName,
                LOC_char* typeName);

        friend void
            ::ccpp_ObjectHomeBridge_us_loadMetamodel(
                DLRL_Exception* exception,
                DK_ObjectHomeAdmin* home,
                void* userData);

        private:
            bool isManaged;

        protected:
            DK_ObjectHomeAdmin* home;

            ObjectHome_impl(
                );

            virtual ~ObjectHome_impl(
                );

            virtual DDS::ReturnCode_t
            registerType(
                DDS::DomainParticipant_ptr participant,
                LOC_char* typeName,
                LOC_char* topicName) = 0;

            virtual void
            loadMetaModel(
                ) = 0;

            DK_ObjectAdmin*
            getObjectRootAdmin(
                DLRL_Exception* exception,
                DDS::ObjectRoot* objectRoot,
                const char* name);

            DK_SelectionAdmin*
            getSelectionAdmin(
                DLRL_Exception* exception,
                DDS::Selection_ptr selection,
                const char* name);

            DK_CacheAccessAdmin*
            getCacheAccessAdmin(
                DLRL_Exception* exception,
                DDS::CacheAccess_ptr access,
                const char* name);

            void
            setSelection(
                DDS::Selection_impl* cpp_selection,
                DK_SelectionAdmin* selection);

        public:

            /**
             * Returns the fully-qualified name (in IDL notation) of the class
             * managed by this ObjectHome. For a class named "Foo" in a package
             * named "demo" this name will be "demo::Foo".
             *
             * @return the fully-qualified name of the class managed by this
             * ObjectHome.
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             */
            virtual char *
            name(
                ) THROW_ORB_EXCEPTIONS;

            /**
             * Returns the SQL expression of the content_filter.
             *
             * @return the SQL expression of the content_filter.
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             */
            virtual char *
            content_filter(
                ) THROW_ORB_EXCEPTIONS;

            /**
             * Returns the ObjectHome that manages the parent-class of the
             * class that is managed by this ObjectHome. (I.e. when class Bar
             * extends from class Foo, then FooHome is the parent for BarHome.)
             * When this ObjectHome has no parent, it returns <code>null</code>.
             * Also when this operation is called before the ObjectHome is
             * registered to a Cache and before the register_all_for_pubsub
             * operation has been successfully called on the cache
             * then this operation will return a <code>null</code>.
             *
             * @return the ObjectHome of the parent-class of the class that is
             * managed by this ObjectHome.
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             */
            virtual DDS::ObjectHome_ptr
            parent(
                ) THROW_ORB_EXCEPTIONS;

            /**
             * Returns the ObjectHomes that manage the sub-classes of the class
             * that is managed by this ObjectHome. (I.e. when class Bar and
             * class Rod both extend from class Foo, then BarHome and RodHome
             * are children of FooHome.) When this ObjectHome has no children,
             * it returns a zero length sequence.
             * Also when this operation is called before the ObjectHome is
             * registered to a Cache and before the register_all_for_pubsub
             * operation has been successfully called on the cache then this
             * operation will return a zero length sequence.
             *
             * @return the ObjectHomes of the sub-classes of the class that is
             * managed by this ObjectHome.
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             */
            virtual DDS::ObjectHomeSeq *
            children(
                ) THROW_ORB_EXCEPTIONS;

            /**
             * Returns the index under which the ObjectHome is registered by the
             * Cache. If the ObjectHome has not yet been registered to the
             * Cache, it returns -1.
             *
             * @return the index under which the ObjectHome is registered by
             * the Cache.
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             */
            virtual CORBA::Long
            registration_index(
                ) THROW_ORB_EXCEPTIONS;

            /**
             * Returns the current setting of the auto_deref attribute. When
             * set to <code>true</code>, the state of each DLRL object is always
             * copied into it. When set to <code>false</code>, the state is only
             * copied into DLRL objects when they are explicitly accessed by the
             * application.
             *
             * @return the current setting of the auto_deref attribute.
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to be
             * deleted.
             */
            virtual CORBA::Boolean
            auto_deref(
                ) THROW_ORB_EXCEPTIONS;

            /**
             * Specifies an SQL expression that is to be used as a
             * contentfilter.
             *
             * <P>The settings for the contentfilter may only be
             * changed when the Cache is still in the INITIAL pubsub state.
             * A PreconditionNotMet exception is thrown otherwise. When using an
             * invalid SQL expression, an SQLError will be thrown.</P>
             * <P>The current implementation does not yet support the notion of
             * a content filter. Therefore invoking this method has no
             * effect.</P>
             *
             * @param expression the SQL expression that is to be used as a
             * contentfilter.
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             * @throws PreconditionNotMet if the Cache is not in the INITIAL
             * pubsub state.
             * @throws DDS::SQLError if the SQL expression is invalid.
             */
            virtual void
            set_content_filter(
                const char * expression) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::SQLError,
                    DDS::PreconditionNotMet);

            /**
             * Specifies the value for the auto_deref attribute.
             *
             * <P>When set to
             * <code>true</code>, the state of each DLRL object is always
             * copied into it. When set to <code>false</code>, the state is only
             * copied into DLRL objects when they are explicitly accessed by the
             * application.</P>
             * <P>The current implementation only supports dereferenced objects.
             * Therefore an auto_deref setting of <code>false</code> is not
             * supported, meaning that invoking this method has no effect.</P>
             *
             * @param value the new value for the auto_deref attribute.
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             */
            virtual void
            set_auto_deref(
                ::CORBA::Boolean value) THROW_ORB_EXCEPTIONS;

            /**
             * Dereferences all DLRL objects of the class that is managed by
             * this home. This means that the state of each of DLRL object is
             * directly copied into it.
             * <P>The current implementation only supports dereferenced objects.
             * Therefore invoking this method has no effect (objects are
             * already dereferenced).</P>
             *
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             */
            virtual void
            deref_all(
                ) THROW_ORB_EXCEPTIONS;

            /**
             * Undereferences all DLRL objects of the class that is managed
             * by this home.
             *
             * <P> This means that the state of each DLRL object is
             * no longer instantly available, but will only be copied into it
             * when explicitly accessed by  the application.</P>
             * <P>The current implementation only supports dereferenced objects.
             * Therefore invoking this method has no effect.</P>
             *
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             */
            virtual void
            underef_all(
                ) THROW_ORB_EXCEPTIONS;

            /**
             * Returns the name of the topic that holds the value for the
             * specified DLRL attribute. If the specified attribute does not
             * exist, a null pointer is returned. If the pubsub-state of the
             * Cache is still set to INITIAL, a PreconditionNotMet exception
             * is thrown.
             *
             * @param attribute_name the name of the DLRL attribute whose
             * corresponding topic needs to be found.
             * @return the name of the topic that holds the specified DLRL
             * attribute.
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             * @throws DDS::PreconditionNotMet is the pubsub_state of the Cache
             * is still set to INITIAL.
             */
            virtual char *
            get_topic_name(
                const char * attribute_name) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet);

            /**
             * Returns the names of all topics that hold the values for all
             * attributes contained in the DLRL class that is managed by this
             * ObjectHome. If the pubsub-state of the Cache is still set to
             * INITIAL, a PreconditionNotMet exception is thrown.
             *
             * @return the names of all topics that hold the values for the
             * attributes of the DLRL class
             * that is managed by this ObjectHome.
             * @throws DDS::AlreadyDeleted if the ObjectHome is considered to
             * be deleted.
             * @throws DDS::PreconditionNotMet is the pubsub_state of the Cache
             * is still set to INITIAL.
             */
            virtual DDS::StringSeq *
            get_all_topic_names(
                ) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet);

            /**
             * Returns the DCPS DataReader associated with the provided topic
             * name, or NULL if no reader was found. If the pubsub-state of the
             * Cache is still set to INITIAL, a PreconditionNotMet exception is
             * thrown.
             *
             * @param topic_name the name of the topic whose corresponding data
             * reader needs to be found.
             * @return The DCPS DataReader associated with the provided
             * topic_name, or NULL if no reader was found.
             * @throws DDS.AlreadyDeleted if the ObjectHome is considered to be
             * deleted.
             * @throws DDS.PreconditionNotMet is the pubsub_state of the Cache
             * is still set to INITIAL.
             */
            virtual DDS::DataReader_ptr
            get_datareader(
                 const char * topic_name) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet);

            /**
             * Returns the DCPS DataWriter associated with the provided topic
             * name, or NULL if no writer was found. If the pubsub-state of the
             * Cache is still set to INITIAL, a PreconditionNotMet exception is
             * thrown.
             *
             * @param topic_name the name of the topic whose corresponding data
             * writer needs to be found.
             * @return The DCPS DataWriter associated with the provided
             * topic_name, or NULL if no writer was found.
             * @throws DDS.AlreadyDeleted if the ObjectHome is considered to be
             * deleted.
             * @throws DDS.PreconditionNotMet is the pubsub_state of the Cache
             * is still set to INITIAL.
             */
            virtual DDS::DataWriter_ptr
            get_datawriter(
                 const char * topic_name) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet);
            /**
             * Returns the DCPS Topic object associated with the provided topic
             * name, or NULL if no topic object was found. If the pubsub-state
             * of the Cache is still set to INITIAL, a PreconditionNotMet
             * exception is thrown.
             *
             * @param topic_name the name of the topic whose corresponding topic
             * object needs to be found.
             * @return The DCPS Topic object  associated with the provided
             * topic_name, or NULL if no topic object was found.
             * @throws DDS.AlreadyDeleted if the ObjectHome is considered to be
             * deleted.
             * @throws DDS.PreconditionNotMet is the pubsub_state of the Cache
             * is still set to INITIAL.
             */
            virtual DDS::Topic_ptr
            get_topic(
                 const char * topic_name) THROW_ORB_AND_USER_EXCEPTIONS(
                    DDS::PreconditionNotMet);

    };
};

#endif /* CCPP_OBJECTHOME_H */
